'use strict';

(function setupMapControls() {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initMapControls);
  } else {
    initMapControls();
  }
})();

function initMapControls() {
  const keyToDirection = {
    ArrowUp: 'north',
    ArrowDown: 'south',
    ArrowLeft: 'west',
    ArrowRight: 'east',
  };
  // Only treat true text-entry elements as hotkey-ignored so that
  // arrow key movement still works when focus is on buttons (e.g. mini-map controls).
  const ignoredTags = new Set(['INPUT', 'TEXTAREA', 'SELECT']);
  const MIN_INTERVAL_MS = 1000;
  let lastMoveAt = 0;
  let requestInFlight = false;
  let lastPlaneId = null;

  function isProbablyLoginPage(html) {
    if (!html) {
      return false;
    }
    const text = String(html);
    const lower = text.toLowerCase();
    const hasEmailField =
      lower.indexOf('name=\"email\"') !== -1 ||
      lower.indexOf('name=\\\"email\\\"') !== -1;
    const hasPasswordField =
      lower.indexOf('type=\"password\"') !== -1 ||
      lower.indexOf('type=\\\"password\\\"') !== -1;
    return hasEmailField && hasPasswordField;
  }

  function handlePlaneChanged(newPlaneId, previousPlaneId) {
    if (!newPlaneId || newPlaneId === previousPlaneId) {
      return;
    }
    const selectEl = document.getElementById('monster-select');
    if (selectEl) {
      const options = Array.from(selectEl.options || []);
      options.forEach((opt, idx) => {
        if (idx === 0) {
          opt.selected = true;
          opt.setAttribute('selected', 'selected');
        } else {
          opt.selected = false;
          opt.removeAttribute('selected');
        }
      });
      selectEl.value = '';
      selectEl.setAttribute('data-last-selected', '');
      selectEl.dispatchEvent(new Event('change', { bubbles: true }));
    }
    if (window.CombatState && typeof window.CombatState === 'object') {
      window.CombatState.lastMonsterId = null;
    }
    try {
      if (
        window.CombatState &&
        window.CombatState.playerId &&
        window.localStorage
      ) {
        const baseKey =
          'combat:last_monster:' + String(window.CombatState.playerId);
        window.localStorage.removeItem(baseKey);
        const planeKey =
          'combat:last_monster_plane:' + String(window.CombatState.playerId);
        window.localStorage.removeItem(planeKey);
      }
    } catch (err) {
      // Ignore storage errors.
    }
  }

  function getMapElements() {
    const container = document.querySelector('[data-map-view]');
    const marker = container ? container.querySelector('[data-map-marker]') : null;
    const mapImageEl = container ? container.querySelector('img') : null;
    return {
      container,
      marker,
      mapImageEl,
      coordsEl: document.querySelector('[data-map-coords]'),
      regionEl: document.querySelector('[data-map-region]'),
      townContainerEl: document.querySelector('[data-map-town-container]'),
      townNameEl: document.querySelector('[data-map-town-name]'),
      noticeEl: document.querySelector('[data-map-notice]'),
      npcListEl: document.querySelector('[data-map-npcs-list]'),
      npcEmptyEl: document.querySelector('[data-map-npcs-empty]'),
    };
  }
  const mapMarkerDefault = {
    offsetLeft: 0,
    offsetTop: 0,
    width: 100,
    height: 100,
    useTileCenter: true,
  };
  // Only add entries here when a plane needs non-default math.
  const mapMarkerConfigs = {};
  const hudPlaneOrder = ['underworld', 'katabasis', 'gaia', 'aerion', 'olympus'];
  const hudPlaneNames = {
    underworld: 'Underworld',
    katabasis: 'Katabasis',
    gaia: 'Aetheria',
    aerion: 'Aerion',
    olympus: 'Olympus',
  };

  function updatePlaneChangeForms(currentPlaneId) {
    const planeId = String(currentPlaneId || '').trim();
    if (!planeId) {
      return;
    }
    const idx = hudPlaneOrder.indexOf(planeId);
    if (idx === -1) {
      return;
    }
    const targets = {
      down: idx > 0 ? hudPlaneOrder[idx - 1] : null,
      up: idx < hudPlaneOrder.length - 1 ? hudPlaneOrder[idx + 1] : null,
    };
    ['down', 'up'].forEach((direction) => {
      const form = document.querySelector(
        `form[data-plane-change-form][data-plane-direction="${direction}"]`,
      );
      if (!(form instanceof HTMLFormElement)) {
        return;
      }
      const hidden = form.querySelector('input[name="plane_id"]');
      const button = form.querySelector('button[type="submit"]');
      const target = targets[direction];
      if (hidden instanceof HTMLInputElement) {
        hidden.value = target || '';
      }
      if (button instanceof HTMLButtonElement) {
        if (target) {
          button.disabled = false;
          button.classList.remove('opacity-60', 'cursor-not-allowed');
          const label = hudPlaneNames[target] || target;
          button.title =
            direction === 'up'
              ? `Ascend to ${label}`
              : `Descend to ${label}`;
        } else {
          button.disabled = true;
          button.classList.add('opacity-60', 'cursor-not-allowed');
          button.title =
            direction === 'up'
              ? 'No higher plane available'
              : 'No lower plane available';
        }
      }
    });
  }

  function getTileRatio(value, size, useTileCenter) {
    if (size <= 1) {
      return 0;
    }
    if (useTileCenter) {
      return (value + 0.5) / Math.max(1, size);
    }
    return value / Math.max(1, size - 1);
  }

  function shouldIgnoreTarget(target) {
    if (!target) {
      return false;
    }
    if (target.isContentEditable) {
      return true;
    }
    return ignoredTags.has((target.tagName || '').toUpperCase());
  }

  function hasSharedActionCooldown() {
    if (
      window.CombatDelay &&
      typeof window.CombatDelay.isOnCooldown === 'function'
    ) {
      try {
        return !!window.CombatDelay.isOnCooldown();
      } catch (err) {
        // Fall through to local throttle if shared cooldown helper fails.
      }
    }
    const now = Date.now();
    return now - lastMoveAt < MIN_INTERVAL_MS;
  }

  function repositionFullMapMarker() {
    const { container, marker } = getMapElements();
    if (!container || !marker) {
      return;
    }
    const planeId = container.dataset.planeId || 'gaia';
    const planeWidth = Math.max(1, Number(container.dataset.planeWidth) || 1);
    const planeHeight = Math.max(1, Number(container.dataset.planeHeight) || 1);
    const rawPosX = Number(container.dataset.posX);
    const rawPosY = Number(container.dataset.posY);
    const posX = Number.isFinite(rawPosX)
      ? Math.max(0, Math.min(planeWidth - 1, rawPosX))
      : 0;
    const posY = Number.isFinite(rawPosY)
      ? Math.max(0, Math.min(planeHeight - 1, rawPosY))
      : 0;
    const bounds = mapMarkerConfigs[planeId] || mapMarkerDefault;
    const useTileCenter = bounds.useTileCenter !== false;
    const xRatio = getTileRatio(posX, planeWidth, useTileCenter);
    const yRatio = getTileRatio(posY, planeHeight, useTileCenter);
    const leftPct =
      bounds.offsetLeft + xRatio * bounds.width;
    const topPct =
      bounds.offsetTop + yRatio * bounds.height;
    marker.style.left = `${leftPct}%`;
    marker.style.top = `${topPct}%`;
  }

  function updateQuestMarkers(markers) {
    const { container } = getMapElements();
    if (!container) {
      return;
    }

    // Clear existing quest markers
    container
      .querySelectorAll('[data-map-quest-marker]')
      .forEach((el) => el.remove());

    if (!Array.isArray(markers) || markers.length === 0) {
      return;
    }

    const planeId = container.dataset.planeId || 'gaia';
    const planeWidth = Math.max(1, Number(container.dataset.planeWidth) || 1);
    const planeHeight = Math.max(1, Number(container.dataset.planeHeight) || 1);
    const bounds = mapMarkerConfigs[planeId] || mapMarkerDefault;
    const useTileCenter = bounds.useTileCenter !== false;

    markers.forEach((marker) => {
      const markerPlane = String(marker.plane || '');
      if (markerPlane && markerPlane !== planeId) {
        return;
      }
      const rawX = Number(marker.x);
      const rawY = Number(marker.y);
      if (!Number.isFinite(rawX) || !Number.isFinite(rawY)) {
        return;
      }
      const x = Math.max(0, Math.min(planeWidth - 1, rawX));
      const y = Math.max(0, Math.min(planeHeight - 1, rawY));
      const xRatio = getTileRatio(x, planeWidth, useTileCenter);
      const yRatio = getTileRatio(y, planeHeight, useTileCenter);
      const leftPct =
        bounds.offsetLeft + xRatio * bounds.width;
      const topPct =
        bounds.offsetTop + yRatio * bounds.height;
      const el = document.createElement('div');
      el.dataset.mapQuestMarker = '1';
      el.className =
        'absolute w-6 h-6 flex items-center justify-center text-yellow-300 text-xl leading-none drop-shadow-[0_0_10px_rgba(251,191,36,0.9)] transform -translate-x-1/2 -translate-y-1/2';
      el.style.left = `${leftPct}%`;
      el.style.top = `${topPct}%`;
      el.title = String(marker.title || 'Quest available here');
      el.textContent = '!';
      container.appendChild(el);
    });
  }

  function updateMapView(payload) {
    if (!payload) {
      return;
    }
    const {
      container,
      marker,
      mapImageEl,
      coordsEl,
      regionEl,
      townContainerEl,
      townNameEl,
      noticeEl,
      npcListEl,
      npcEmptyEl,
    } =
      getMapElements();
    const coords = payload.coords || {};
    const plane = payload.plane || {};
    if (container) {
      if (typeof plane.id === 'string' && plane.id !== '') {
        container.dataset.planeId = plane.id;
      }
      if (typeof plane.width === 'number') {
        container.dataset.planeWidth = String(plane.width);
      }
      if (typeof plane.height === 'number') {
        container.dataset.planeHeight = String(plane.height);
      }
      if (typeof coords.x === 'number') {
        container.dataset.posX = String(coords.x);
      }
      if (typeof coords.y === 'number') {
        container.dataset.posY = String(coords.y);
      }
      if (marker) {
        repositionFullMapMarker();
      }
      if (
        mapImageEl &&
        typeof payload.map_image_url === 'string' &&
        payload.map_image_url !== '' &&
        mapImageEl.getAttribute('src') !== payload.map_image_url
      ) {
        mapImageEl.setAttribute('src', payload.map_image_url);
      }
    }
    const nextPlaneId =
      typeof plane.id === 'string' && plane.id !== '' ? plane.id : null;
    if (nextPlaneId) {
      if (lastPlaneId !== null && nextPlaneId !== lastPlaneId) {
        handlePlaneChanged(nextPlaneId, lastPlaneId);
      }
      lastPlaneId = nextPlaneId;
      updatePlaneChangeForms(nextPlaneId);
    }
    if (coordsEl && typeof coords.x === 'number' && typeof coords.y === 'number') {
      const pad3 = (value) => {
        const n = Number.isFinite(value) ? Math.max(0, Math.trunc(value)) : 0;
        return String(n).padStart(3, '0');
      };
      const plane = payload.plane || {};
      let planeAbbrSource = '';
      if (typeof plane.name === 'string' && plane.name !== '') {
        planeAbbrSource = plane.name;
      } else if (typeof plane.id === 'string' && plane.id !== '') {
        planeAbbrSource = plane.id;
      }
      let planeAbbr = planeAbbrSource ? planeAbbrSource.slice(0, 3) : 'Pln';
      planeAbbr =
        planeAbbr.charAt(0).toUpperCase() + planeAbbr.slice(1).toLowerCase();
      coordsEl.textContent = `Loc: ${pad3(coords.x)},${planeAbbr},${pad3(coords.y)}`;
    }
    if (regionEl) {
      const zone =
        typeof payload.zone_name === 'string'
          ? payload.zone_name.trim()
          : '';
      if (zone !== '') {
        regionEl.textContent = zone;
      }
    }
    if (townContainerEl && townNameEl) {
      const rawTown = typeof payload.town_name === 'string'
        ? payload.town_name.trim()
        : '';
      if (rawTown !== '') {
        townNameEl.textContent = rawTown;
        townContainerEl.classList.remove('hidden');
      } else {
        townNameEl.textContent = '';
        townContainerEl.classList.add('hidden');
      }
    }
    if (noticeEl) {
      const message = payload.message || '';
      if (message) {
        noticeEl.textContent = message;
        noticeEl.classList.remove('hidden');
      } else {
        noticeEl.textContent = '';
        noticeEl.classList.add('hidden');
      }
    }
    if (payload.beast_message && window.gameNotifications) {
      window.gameNotifications.show(payload.beast_message);
    }
    if (npcListEl && npcEmptyEl && Array.isArray(payload.npcs)) {
      npcListEl.innerHTML = '';
      if (payload.npcs.length === 0) {
        npcEmptyEl.classList.remove('hidden');
        npcListEl.classList.add('hidden');
      } else {
        payload.npcs.forEach((npc) => {
          const name = npc && npc.name ? String(npc.name) : 'NPC';
          const li = document.createElement('li');
          li.className = 'flex items-center justify-between gap-2';

          const nameSpan = document.createElement('span');
          nameSpan.className = 'font-semibold text-amber-100';
          nameSpan.textContent = name;

          const hintSpan = document.createElement('span');
          hintSpan.className = 'text-[11px] text-gray-500';
          hintSpan.textContent = `/m ${name}: hello`;

          li.appendChild(nameSpan);
          li.appendChild(hintSpan);
          npcListEl.appendChild(li);
        });
        npcEmptyEl.classList.add('hidden');
        npcListEl.classList.remove('hidden');
      }
    }

    // Only update quest markers when the payload explicitly includes them.
    // This avoids wiping out preloaded markers (from the initial page render)
    // when HUD updates or other payloads omit quest marker data.
    if (Array.isArray(payload.quest_markers)) {
      updateQuestMarkers(payload.quest_markers);
    }

    // Also update quests list if payload includes available quests.
    if (payload.available_quests && Array.isArray(payload.available_quests)) {
      updateQuestsFromPayload(payload.available_quests);
    }
  }

  async function refreshKingdomPanelFromServer() {
    const panel = document.querySelector('[data-kingdom-panel]');
    if (!panel) {
      return;
    }
    try {
      const response = await fetch('game.php?tab=kingdoms', {
        method: 'GET',
        credentials: 'same-origin',
        headers: {
          Accept: 'text/html',
        },
      });
      if (!response.ok) {
        return;
      }
      const html = await response.text();
      if (!html) {
        return;
      }
      const tmp = document.createElement('div');
      tmp.innerHTML = html;
      const freshPanel = tmp.querySelector('[data-kingdom-panel]');
      if (!freshPanel) {
        return;
      }
      const existingContent = panel.querySelector('[data-kingdom-content]');
      const freshContent = freshPanel.querySelector('[data-kingdom-content]');
      if (existingContent && freshContent) {
        existingContent.innerHTML = freshContent.innerHTML;
      }
      if (
        window.Kingdoms &&
        typeof window.Kingdoms.rebindActionBar === 'function'
      ) {
        window.Kingdoms.rebindActionBar();
      }
    } catch (err) {
      // Swallow errors – movement already succeeded; kingdom panel can fall
      // back to its periodic polling.
    }
  }

  function updateFromHud(payload) {
    if (!payload || typeof payload !== 'object') {
      return;
    }
    updateMapView(payload);
  }

  function updateQuestsFromPayload(quests) {
    const panel = document.querySelector('[data-quests-available-panel]');
    if (!panel) {
      return;
    }
    panel.innerHTML = '';
    if (!Array.isArray(quests) || quests.length === 0) {
      const emptyEl = document.createElement('div');
      emptyEl.className = 'text-gray-400';
      emptyEl.textContent = 'No quests available at this location.';
      panel.appendChild(emptyEl);
      return;
    }
    quests.forEach((quest) => {
      const typeText = String(quest.type || '');
      const card = document.createElement('div');
      card.className = 'border border-gray-700 rounded-md p-3 bg-gray-900';

      const contentRow = document.createElement('div');
      contentRow.className = 'flex items-start gap-3';

      const imgWrap = document.createElement('div');
      imgWrap.className = 'flex-shrink-0';
      const img = document.createElement('img');
      const rawIcon = typeof quest.icon === 'string' ? quest.icon.trim() : '';
      let iconPath =
        (window.questItemPlaceholderSrc &&
          String(window.questItemPlaceholderSrc)) ||
        'assets/img/ui/quest_item_placeholder.jpg';
      if (rawIcon) {
        let file = rawIcon.replace(/^\/+/, '');
        if (file.toLowerCase().startsWith('assets/img/ui/')) {
          file = file.slice('assets/img/ui/'.length);
        }
        iconPath = 'assets/img/ui/' + file;
      }
      img.src = iconPath;
      img.alt = String(quest.title || 'Quest');
      img.className = 'w-12 h-12 object-contain rounded';
      imgWrap.appendChild(img);
      contentRow.appendChild(imgWrap);

      const textWrap = document.createElement('div');
      textWrap.className = 'flex-1';

      const title = document.createElement('div');
      title.className = 'font-semibold text-gray-100 mb-1';
      title.textContent = String(quest.title || 'Quest');

      const desc = document.createElement('div');
      desc.className = 'text-gray-300 mb-2 whitespace-pre-line';
      desc.textContent = String(quest.description || '');

      const meta = document.createElement('div');
      meta.className = 'text-xs text-gray-400 mb-2';
      const minLevel = Number.isFinite(quest.min_level) ? quest.min_level : '';
      meta.textContent = `Type: ${typeText} • Min Level: ${minLevel}`;

      const form = document.createElement('form');
      form.method = 'post';

      const csrfInput = document.createElement('input');
      csrfInput.type = 'hidden';
      csrfInput.name = 'csrf_token';
      csrfInput.value = window.csrfToken || '';

      const actionInput = document.createElement('input');
      actionInput.type = 'hidden';
      actionInput.name = 'action';
      actionInput.value = 'accept_quest';

      const idInput = document.createElement('input');
      idInput.type = 'hidden';
      idInput.name = 'quest_id';
      idInput.value = String(quest.id || '');

      const button = document.createElement('button');
      button.type = 'submit';
      button.className = 'px-3 py-1.5 rounded-md bg-purple-600 hover:bg-purple-500 text-xs font-semibold text-white';
      button.textContent = 'Accept Quest';

      form.appendChild(csrfInput);
      form.appendChild(actionInput);
      form.appendChild(idInput);
      form.appendChild(button);

      textWrap.appendChild(title);
      textWrap.appendChild(desc);
      textWrap.appendChild(meta);
      textWrap.appendChild(form);

      contentRow.appendChild(textWrap);

      card.appendChild(contentRow);

      panel.appendChild(card);
    });
  }

  async function sendMove(direction) {
    if (requestInFlight) {
      return;
    }
    if (hasSharedActionCooldown()) {
      return;
    }
    const dir = (direction || '').trim();
    if (!dir) {
      return;
    }

    const usingSharedCooldown =
      !!window.CombatDelay &&
      typeof window.CombatDelay.beginExternalCooldown === 'function';
    if (!usingSharedCooldown) {
      lastMoveAt = Date.now();
    }
    requestInFlight = true;
    try {
      const response = await fetch('api/map_move.php', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
        },
        body: new URLSearchParams({
          direction: dir,
          csrf_token: window.csrfToken || '',
        }),
      });
      const contentType = response.headers.get('content-type') || '';
      const isJson = contentType.indexOf('application/json') !== -1;
      if (response.status === 401) {
        if (window.handlePossibleLogoutSignal && typeof window.handlePossibleLogoutSignal === 'function') {
          window.handlePossibleLogoutSignal();
        } else if (window.gameNotifications && typeof window.gameNotifications.show === 'function') {
          window.gameNotifications.show('You have been logged out. Please refresh and log in again.');
        }
        return;
      }
      if (!isJson) {
        try {
          const text = await response.text();
          if (
            text.indexOf('<title>Login</title>') !== -1 ||
            isProbablyLoginPage(text)
          ) {
            if (window.handlePossibleLogoutSignal && typeof window.handlePossibleLogoutSignal === 'function') {
              window.handlePossibleLogoutSignal();
            } else if (
              window.gameNotifications &&
              typeof window.gameNotifications.show === 'function'
            ) {
              window.gameNotifications.show(
                'You have been logged out. Please refresh and log in again.',
              );
            }
          }
        } catch (err) {
          // swallow parse errors for non-JSON responses
        }
        return;
      }
      if (response.status === 429) {
        // Hard rate limit is enforced server-side, but the shared delay bar
        // is the primary UX signal now, so we skip any extra toast here.
        return;
      }
      if (!response.ok || !isJson) {
        return;
      }
      const payload = await response.json();
      if (payload) {
        updateMapView(payload);
      }
      if (payload && payload.success) {
        if (window.CombatUI && typeof window.CombatUI.clearLog === 'function') {
          window.CombatUI.clearLog();
        }
        if (window.CombatUI && typeof window.CombatUI.endCombat === 'function') {
          window.CombatUI.endCombat();
        }
        if (
          window.CombatDelay &&
          typeof window.CombatDelay.beginExternalCooldown === 'function'
        ) {
          let delayMs = null;
          if (
            typeof window.CombatDelay.getDelayDurationMs === 'function'
          ) {
            try {
              delayMs = window.CombatDelay.getDelayDurationMs();
            } catch (err) {
              delayMs = null;
            }
          }
          window.CombatDelay.beginExternalCooldown(
            typeof delayMs === 'number' && delayMs > 0 ? delayMs : undefined,
          );
        }
        if (typeof window.updatePlayerHud === 'function') {
          const coords = payload.coords || {};
          const plane = payload.plane || {};
          window.updatePlayerHud({
            pos_x: typeof coords.x === 'number' ? coords.x : undefined,
            pos_y: typeof coords.y === 'number' ? coords.y : undefined,
            zone_name: payload.zone_name,
            town_name: payload.town_name,
            current_plane: plane.id,
            plane_name: plane.name,
            plane_width: plane.width,
            plane_height: plane.height,
          });
        }
        if (payload) {
          window.lastMapPayload = payload;
          if (
            window.QuestRefresh &&
            typeof window.QuestRefresh.refreshActive === 'function'
          ) {
            window.QuestRefresh.refreshActive();
          }
        }

        // If the player is currently on the Kingdoms tab, refresh just the
        // kingdoms panel HTML from the server so it reflects the kingdom
        // (or lack thereof) on the new tile, without a full page reload
        // that would cause chat to flicker.
        const activeTabEl = document.querySelector('a[data-active-tab="1"]');
        if (
          activeTabEl &&
          activeTabEl.dataset &&
          activeTabEl.dataset.tabId === 'kingdoms'
        ) {
          refreshKingdomPanelFromServer();
        }
      } else if (payload && payload.message && window.gameNotifications) {
        window.gameNotifications.show(payload.message);
      }
      if (
        payload &&
        window.CombatUI &&
        typeof window.CombatUI.updateMonsterOptionsLabel === 'function'
      ) {
        window.CombatUI.updateMonsterOptionsLabel(payload.tile_rarity);
      }
    } catch (err) {
      console.error('Failed to move on map', err);
    } finally {
      requestInFlight = false;
    }
  }

  async function sendPlaneChange(targetPlaneId) {
    if (requestInFlight) {
      return;
    }
    if (hasSharedActionCooldown()) {
      return;
    }
    const planeId = String(targetPlaneId || '').trim();
    if (!planeId) {
      return;
    }

    const usingSharedCooldown =
      !!window.CombatDelay &&
      typeof window.CombatDelay.beginExternalCooldown === 'function';
    if (!usingSharedCooldown) {
      lastMoveAt = Date.now();
    }
    requestInFlight = true;
    try {
      const response = await fetch('api/map_change_plane.php', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
        },
        body: new URLSearchParams({
          plane_id: planeId,
          csrf_token: window.csrfToken || '',
        }),
      });
      const contentType = response.headers.get('content-type') || '';
      const isJson = contentType.indexOf('application/json') !== -1;
      if (response.status === 401) {
        if (
          window.handlePossibleLogoutSignal &&
          typeof window.handlePossibleLogoutSignal === 'function'
        ) {
          window.handlePossibleLogoutSignal();
        } else if (
          window.gameNotifications &&
          typeof window.gameNotifications.show === 'function'
        ) {
          window.gameNotifications.show(
            'You have been logged out. Please refresh and log in again.',
          );
        }
        return;
      }
      if (!isJson) {
        try {
          const text = await response.text();
          if (
            text.indexOf('<title>Login</title>') !== -1 ||
            isProbablyLoginPage(text)
          ) {
            if (
              window.handlePossibleLogoutSignal &&
              typeof window.handlePossibleLogoutSignal === 'function'
            ) {
              window.handlePossibleLogoutSignal();
            } else if (
              window.gameNotifications &&
              typeof window.gameNotifications.show === 'function'
            ) {
              window.gameNotifications.show(
                'You have been logged out. Please refresh and log in again.',
              );
            }
          }
        } catch (err) {
          // swallow parse errors for non-JSON responses
        }
        return;
      }
      if (response.status === 429) {
        return;
      }
      if (!response.ok || !isJson) {
        return;
      }

      const payload = await response.json();
      if (payload) {
        updateMapView(payload);
      }
      if (payload && payload.success) {
        if (window.CombatUI && typeof window.CombatUI.clearLog === 'function') {
          window.CombatUI.clearLog();
        }
        if (window.CombatUI && typeof window.CombatUI.endCombat === 'function') {
          window.CombatUI.endCombat();
        }
        if (
          window.CombatDelay &&
          typeof window.CombatDelay.beginExternalCooldown === 'function'
        ) {
          let delayMs = Number(payload.delay_ms);
          if (!Number.isFinite(delayMs) || delayMs <= 0) {
            delayMs = null;
            if (
              typeof window.CombatDelay.getDelayDurationMs === 'function'
            ) {
              try {
                delayMs = window.CombatDelay.getDelayDurationMs();
              } catch (err) {
                delayMs = null;
              }
            }
          }
          window.CombatDelay.beginExternalCooldown(
            typeof delayMs === 'number' && delayMs > 0 ? delayMs : undefined,
          );
        }
        if (typeof window.updatePlayerHud === 'function') {
          const coords = payload.coords || {};
          const plane = payload.plane || {};
          window.updatePlayerHud({
            pos_x: typeof coords.x === 'number' ? coords.x : undefined,
            pos_y: typeof coords.y === 'number' ? coords.y : undefined,
            zone_name: payload.zone_name,
            town_name: payload.town_name,
            current_plane: plane.id,
            plane_name: plane.name,
            plane_width: plane.width,
            plane_height: plane.height,
            map_image_url:
              typeof payload.map_image_url === 'string'
                ? payload.map_image_url
                : undefined,
          });
        }
        try {
          const hudRes = await fetch('api/hud_state.php', {
            credentials: 'same-origin',
          });
          if (hudRes.ok) {
            const hudData = await hudRes.json();
            if (
              hudData &&
              hudData.success &&
              hudData.char &&
              typeof window.updatePlayerHud === 'function'
            ) {
              window.updatePlayerHud(hudData.char);
            }
          }
        } catch (err) {
          // Best-effort: plane change already succeeded.
        }
        if (payload) {
          window.lastMapPayload = payload;
          if (
            window.QuestRefresh &&
            typeof window.QuestRefresh.refreshActive === 'function'
          ) {
            window.QuestRefresh.refreshActive();
          }
        }
        const activeTabEl = document.querySelector('a[data-active-tab="1"]');
        if (
          activeTabEl &&
          activeTabEl.dataset &&
          activeTabEl.dataset.tabId === 'kingdoms'
        ) {
          refreshKingdomPanelFromServer();
        }
      } else if (payload && payload.message && window.gameNotifications) {
        window.gameNotifications.show(payload.message);
      }
      if (
        payload &&
        window.CombatUI &&
        typeof window.CombatUI.updateMonsterOptionsLabel === 'function'
      ) {
        window.CombatUI.updateMonsterOptionsLabel(payload.tile_rarity);
      }
      if (
        payload &&
        window.CombatUI &&
        typeof window.CombatUI.replaceMonsterCatalog === 'function' &&
        Array.isArray(payload.monster_catalog)
      ) {
        window.CombatUI.replaceMonsterCatalog(
          payload.monster_catalog,
          payload.tile_rarity,
        );
      }
      if (
        payload &&
        payload.success &&
        window.CombatUI &&
        typeof window.CombatUI.refreshBeastsNow === 'function'
      ) {
        window.CombatUI.refreshBeastsNow();
      }
    } catch (err) {
      console.error('Failed to change plane', err);
    } finally {
      requestInFlight = false;
    }
  }

  document.addEventListener('keydown', function handleKeydown(event) {
    if (!keyToDirection[event.key]) {
      return;
    }
    if (shouldIgnoreTarget(event.target)) {
      return;
    }
    event.preventDefault();
    sendMove(keyToDirection[event.key]);
  });

  document.addEventListener('submit', (event) => {
    const form = event.target;
    if (!(form instanceof HTMLFormElement)) {
      return;
    }
    if (!form.matches('form[data-map-move-form]')) {
      return;
    }
    event.preventDefault();
    const directionField = form.querySelector('input[name="direction"]');
    const direction = directionField ? String(directionField.value || '') : '';
    if (direction) {
      sendMove(direction);
    }
  });

  document.addEventListener('submit', (event) => {
    const form = event.target;
    if (!(form instanceof HTMLFormElement)) {
      return;
    }
    if (!form.matches('form[data-plane-change-form]')) {
      return;
    }
    event.preventDefault();
    if (hasSharedActionCooldown()) {
      return;
    }
    const planeField = form.querySelector('input[name="plane_id"]');
    const planeId = planeField ? String(planeField.value || '') : '';
    if (planeId) {
      sendPlaneChange(planeId);
    }
  });

  repositionFullMapMarker();

  // If the server provided quest markers on initial page load, render them
  // immediately so the "!" icons are visible before any movement occurs.
  if (Array.isArray(window.initialQuestMarkers)) {
    updateQuestMarkers(window.initialQuestMarkers);
  }

  if (window.lastMapPayload) {
    updateMapView(window.lastMapPayload);
  }
  const hudCard = document.getElementById('hud-location-card');
  if (hudCard && hudCard.dataset && hudCard.dataset.planeId) {
    updatePlaneChangeForms(hudCard.dataset.planeId);
  }

  window.MapControls = window.MapControls || {};
  window.MapControls.updateFromHud = updateFromHud;

  window.CombatUI = window.CombatUI || {};
  if (typeof window.CombatUI.clearLog !== 'function') {
    window.CombatUI.clearLog = function noopClearLog() {};
  }
}
