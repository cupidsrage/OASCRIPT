'use strict';

(function initChat() {
  const messagesEl = document.getElementById('chat-messages');
  const formEl = document.getElementById('chat-form');
  const inputEl = document.getElementById('chat-input');
  const modeEl = document.getElementById('chat-mode');
  if (!messagesEl || !formEl || !inputEl) {
    return;
  }

  let autoScrollTop = true;
  let lastMessageId = 0;
  let isSending = false;
  let lastMessage = '';
  let lastSentAt = 0;
  let logoutSignalCount = 0;
  let logoutRedirected = false;
  const LOGOUT_SIGNAL_THRESHOLD = 2;
  const CHAT_POLL_INTERVAL_MS = 2000;
  const CHAT_HIDDEN_POLL_INTERVAL_MS = 15000;
  const CLEAR_STORAGE_KEY = 'oa_chat_clear_id:' + window.location.pathname;
  let clearedThroughId = 0;
  let initialFetchDispatched = false;
  let pollTimer = null;
  let pollIntervalMs = 0;
  let lastHudEventCheckAt = 0;
  const HUD_EVENT_POLL_MS = 5000;

  try {
    const storedClear = window.localStorage ? window.localStorage.getItem(CLEAR_STORAGE_KEY) : null;
    const parsedClear = parseInt(storedClear || '', 10);
    if (!Number.isNaN(parsedClear) && parsedClear > 0) {
      clearedThroughId = parsedClear;
    }
  } catch (err) {
    clearedThroughId = 0;
  }

  window.handlePossibleLogoutSignal = function handlePossibleLogoutSignal() {
    logoutSignalCount += 1;
    if (logoutSignalCount < LOGOUT_SIGNAL_THRESHOLD || logoutRedirected) {
      return;
    }
    logoutRedirected = true;
    if (window.gameNotifications && typeof window.gameNotifications.show === 'function') {
      window.gameNotifications.show('You have been logged out. Redirecting to login...');
    }
    window.location.href = 'login.php';
  };

  function resetLogoutSignalCount() {
    logoutSignalCount = 0;
  }

  function updateCount() {
    const items = messagesEl.querySelectorAll('div');
    let count = 0;
    items.forEach((el) => {
      if (!el.classList.contains('placeholder')) {
        count++;
      }
    });
    return count;
  }

  function renderPlaceholder(text) {
    renderMessages('<div class="text-gray-500 placeholder">' + text + '</div>');
  }

  consumeChatLinkParam();

  const itemTooltipCache = new Map();
  let itemTooltipEl = null;
  let itemTooltipVisibleFor = null;
  let tooltipHideTimer = null;

  function ensureTooltipEl() {
    if (itemTooltipEl) return itemTooltipEl;
    const el = document.createElement('div');
    el.className = 'chat-item-tooltip hidden';
    document.body.appendChild(el);
    itemTooltipEl = el;
    return el;
  }

  function positionTooltip(anchorEl) {
    if (!itemTooltipEl || !anchorEl) return;
    const rect = anchorEl.getBoundingClientRect();
    const tooltipRect = itemTooltipEl.getBoundingClientRect();
    const padding = 8;
    const top = Math.max(
      padding,
      rect.top + window.scrollY - tooltipRect.height - 6,
    );
    let left = rect.left + window.scrollX + rect.width / 2 - tooltipRect.width / 2;
    left = Math.max(padding, Math.min(left, window.scrollX + window.innerWidth - tooltipRect.width - padding));
    itemTooltipEl.style.top = top + 'px';
    itemTooltipEl.style.left = left + 'px';
  }

  function showTooltip(anchorEl, html, linkId) {
    const el = ensureTooltipEl();
    el.innerHTML = html;
    el.classList.remove('hidden');
    itemTooltipVisibleFor = linkId;
    positionTooltip(anchorEl);
  }

  function hideTooltip() {
    if (!itemTooltipEl) return;
    itemTooltipEl.classList.add('hidden');
    itemTooltipVisibleFor = null;
  }

  function scheduleHideTooltip() {
    if (tooltipHideTimer) {
      window.clearTimeout(tooltipHideTimer);
    }
    tooltipHideTimer = window.setTimeout(() => {
      hideTooltip();
    }, 200);
  }

  function cancelHideTooltip() {
    if (tooltipHideTimer) {
      window.clearTimeout(tooltipHideTimer);
      tooltipHideTimer = null;
    }
  }

  function fetchItemTooltip(linkId) {
    if (itemTooltipCache.has(linkId)) {
      return Promise.resolve(itemTooltipCache.get(linkId));
    }
    return fetch('api/chat_item_tooltip.php?id=' + encodeURIComponent(String(linkId)), { credentials: 'same-origin' })
      .then((res) => {
        if (!res.ok) return '';
        return res.text();
      })
      .then((html) => {
        const trimmed = (html || '').trim();
        itemTooltipCache.set(linkId, trimmed);
        return trimmed;
      })
      .catch(() => '');
  }

  messagesEl.addEventListener('mouseover', function handleItemHover(e) {
    const target = e.target;
    if (!target || !target.classList || !target.classList.contains('chat-item-link')) {
      return;
    }
    cancelHideTooltip();
    const linkId = parseInt(target.getAttribute('data-chat-item-id') || '', 10);
    if (Number.isNaN(linkId) || linkId <= 0) return;
    if (itemTooltipVisibleFor === linkId) return;
    fetchItemTooltip(linkId).then((html) => {
      if (!html) return;
      showTooltip(target, html, linkId);
    });
  });

  messagesEl.addEventListener('mouseout', function handleItemOut(e) {
    const target = e.target;
    if (!target || !target.classList || !target.classList.contains('chat-item-link')) {
      return;
    }
    scheduleHideTooltip();
  });

  document.addEventListener('click', function handleDocumentClick(e) {
    const target = e.target;
    if (target && target.classList && target.classList.contains('chat-item-link')) {
      e.preventDefault();
      return;
    }
    if (itemTooltipEl && !itemTooltipEl.classList.contains('hidden')) {
      hideTooltip();
    }
  });

  window.addEventListener('scroll', function handleScroll() {
    if (itemTooltipEl && !itemTooltipEl.classList.contains('hidden')) {
      hideTooltip();
    }
  });

  function appendTokenToInput(token) {
    if (!token) return;
    const current = inputEl.value || '';
    const needsSpace = current.length > 0 && !/\s$/.test(current);
    const prefix = needsSpace ? ' ' : '';
    inputEl.value = current + prefix + token;
  }

  function consumeChatLinkParam() {
    try {
      const url = new URL(window.location.href);
      const token = url.searchParams.get('chat_link');
      if (!token) return;
      appendTokenToInput(token);
      if (window.gameNotifications && typeof window.gameNotifications.show === 'function') {
        window.gameNotifications.show('Item link added to chat.');
      }
      url.searchParams.delete('chat_link');
      window.history.replaceState({}, '', url.toString());
    } catch (err) {
      // Ignore URL parsing failures.
    }
  }

  function applyEventBadges(expActive, goldActive) {
    const expBadge = document.getElementById('hud-exp-event-badge');
    const goldBadge = document.getElementById('hud-gold-event-badge');
    const wrapper = document.getElementById('hud-event-badges');
    const nextKey = `${expActive ? '1' : '0'}:${goldActive ? '1' : '0'}`;
    const lastKey = wrapper ? wrapper.getAttribute('data-event-state') : null;
    if (wrapper && lastKey === nextKey) {
      return;
    }
    if (expBadge) {
      expBadge.classList.toggle('hidden', !expActive);
    }
    if (goldBadge) {
      goldBadge.classList.toggle('hidden', !goldActive);
    }
    if (wrapper) {
      wrapper.setAttribute('data-event-state', nextKey);
      wrapper.classList.toggle('hidden', !expActive && !goldActive);
    }
  }

  function maybePollHudState() {
    if (typeof window.updatePlayerHud !== 'function') {
      // We still want to update badges even if the HUD helper is missing.
      // Continue without early return.
    }
    const now = Date.now();
    if (now - lastHudEventCheckAt < HUD_EVENT_POLL_MS) {
      return;
    }
    lastHudEventCheckAt = now;
    fetch('api/hud_state.php', { credentials: 'same-origin' })
      .then((res) => {
        if (!res.ok) return null;
        return res.json();
      })
      .then((data) => {
        if (!data || !data.success || !data.char) return;
        const c = data.char;
        const events = data.events || {};
        const expActive = !!events.exp;
        const goldActive = !!events.gold;
        if (typeof window.updatePlayerHud === 'function') {
          window.updatePlayerHud({
            hp: c.hp || 0,
            max_hp: c.max_hp || 0,
            gold: c.gold || 0,
            silver: c.silver || 0,
            exp: c.exp || 0,
            exp_to_next: c.exp_to_next || 0,
            level: c.level || 0,
            stat_points: data.stat_points || 0,
            pos_x: typeof c.pos_x === 'number' ? c.pos_x : undefined,
            pos_y: typeof c.pos_y === 'number' ? c.pos_y : undefined,
            current_plane: typeof c.current_plane === 'string' ? c.current_plane : undefined,
            plane_name: typeof c.plane_name === 'string' ? c.plane_name : undefined,
            plane_width: typeof c.plane_width === 'number' ? c.plane_width : undefined,
            plane_height: typeof c.plane_height === 'number' ? c.plane_height : undefined,
            map_image_url: typeof c.map_image_url === 'string' ? c.map_image_url : undefined,
            zone_name: typeof c.zone_name === 'string' ? c.zone_name : undefined,
            town_name: typeof c.town_name === 'string' ? c.town_name : undefined,
            exp_event_active: expActive,
            gold_event_active: goldActive,
          });
        }
        applyEventBadges(expActive, goldActive);
      })
      .catch(() => {
        // Swallow HUD refresh errors; chat is still updated.
      });
  }

  function forcePollHudState(previousPlaneId) {
    fetch('api/hud_state.php', { credentials: 'same-origin' })
      .then((res) => {
        if (!res.ok) return null;
        return res.json();
      })
      .then((data) => {
        if (!data || !data.success || !data.char) return;
        const c = data.char;
        const nextPlaneId =
          typeof c.current_plane === 'string' ? c.current_plane : '';
        const events = data.events || {};
        const expActive = !!events.exp;
        const goldActive = !!events.gold;
        if (typeof window.updatePlayerHud === 'function') {
          window.updatePlayerHud({
            hp: c.hp || 0,
            max_hp: c.max_hp || 0,
            gold: c.gold || 0,
            silver: c.silver || 0,
            exp: c.exp || 0,
            exp_to_next: c.exp_to_next || 0,
            level: c.level || 0,
            stat_points: data.stat_points || 0,
            pos_x: typeof c.pos_x === 'number' ? c.pos_x : undefined,
            pos_y: typeof c.pos_y === 'number' ? c.pos_y : undefined,
            current_plane: typeof c.current_plane === 'string' ? c.current_plane : undefined,
            plane_name: typeof c.plane_name === 'string' ? c.plane_name : undefined,
            plane_width: typeof c.plane_width === 'number' ? c.plane_width : undefined,
            plane_height: typeof c.plane_height === 'number' ? c.plane_height : undefined,
            map_image_url: typeof c.map_image_url === 'string' ? c.map_image_url : undefined,
            zone_name: typeof c.zone_name === 'string' ? c.zone_name : undefined,
            town_name: typeof c.town_name === 'string' ? c.town_name : undefined,
            exp_event_active: expActive,
            gold_event_active: goldActive,
          });
        }
        applyEventBadges(expActive, goldActive);
        if (
          previousPlaneId &&
          nextPlaneId &&
          previousPlaneId !== nextPlaneId
        ) {
          window.location.reload();
        }
      })
      .catch(() => {
        // Swallow HUD refresh errors; chat is still updated.
      });
  }

  function clearChatWindow() {
    updateLastMessageIdFromDom();
    clearedThroughId = Math.max(clearedThroughId, lastMessageId);
    try {
      if (window.localStorage) {
        window.localStorage.setItem(CLEAR_STORAGE_KEY, String(clearedThroughId));
      }
    } catch (err) {
      /* swallow */
    }
    messagesEl.innerHTML = '';
    updateCount();
    updateLastMessageIdFromDom();
    autoScrollTop = true;
  }

  function getSinceId() {
    return Math.max(lastMessageId, clearedThroughId);
  }

  function applyClearFilter(html) {
    if (!html || clearedThroughId <= 0) {
      return html;
    }
    const tmp = document.createElement('div');
    tmp.innerHTML = html;
    const children = Array.from(tmp.children);
    children.forEach((child) => {
      const rawId = child.getAttribute('data-message-id') || '';
      const id = parseInt(rawId, 10);
      if (!Number.isNaN(id) && id <= clearedThroughId) {
        child.remove();
      }
    });
    return tmp.innerHTML;
  }

  function updateLastMessageIdFromDom() {
    const items = messagesEl.querySelectorAll('[data-message-id]');
    let maxId = lastMessageId;
    items.forEach((el) => {
      const raw = el.getAttribute('data-message-id') || '';
      const id = parseInt(raw, 10);
      if (!Number.isNaN(id) && id > maxId) {
        maxId = id;
      }
    });
    lastMessageId = maxId;
  }

  function isSelectionInsideMessages() {
    var sel = null;
    if (typeof window.getSelection === 'function') {
      sel = window.getSelection();
    } else if (typeof document.getSelection === 'function') {
      sel = document.getSelection();
    }
    if (!sel || sel.isCollapsed) {
      return false;
    }

    function nodeWithinMessages(node) {
      while (node) {
        if (node === messagesEl) {
          return true;
        }
        node = node.parentNode;
      }
      return false;
    }

    // Check both anchor and focus nodes so partial selections are detected.
    if (sel.anchorNode && nodeWithinMessages(sel.anchorNode)) {
      return true;
    }
    if (sel.focusNode && nodeWithinMessages(sel.focusNode)) {
      return true;
    }
    return false;
  }

  function renderMessages(html) {
    const previousTop = messagesEl.scrollTop;
    const previousHeight = messagesEl.scrollHeight;
    messagesEl.innerHTML = html;
    updateCount();
    updateLastMessageIdFromDom();
    if (autoScrollTop) {
      messagesEl.scrollTop = 0;
    } else {
      const heightDiff = messagesEl.scrollHeight - previousHeight;
      messagesEl.scrollTop = Math.max(
        0,
        Math.min(messagesEl.scrollHeight, previousTop + heightDiff),
      );
    }
  }

  messagesEl.addEventListener('scroll', function handleScroll() {
    autoScrollTop = messagesEl.scrollTop <= 5;
  });

  // Clickable player names to prefill /m whispers
  messagesEl.addEventListener('click', function handleNameClick(e) {
    let el = e.target;
    if (!el) {
      return;
    }

    function findClosest(start, selector, stopEl) {
      if (!start) {
        return null;
      }
      if (typeof start.closest === 'function') {
        const found = start.closest(selector);
        if (found && stopEl && !stopEl.contains(found)) {
          return null;
        }
        return found;
      }
      let node = start;
      while (node && node !== stopEl) {
        if (node.classList && selector === '.chat-player-name' && node.classList.contains('chat-player-name')) {
          return node;
        }
        node = node.parentNode;
      }
      return null;
    }

    const nameEl = findClosest(el, '.chat-player-name', messagesEl);
    if (nameEl && nameEl.getAttribute) {
      const name = nameEl.getAttribute('data-name') || '';
      const trimmed = name.replace(/:$/, '').trim();
      if (!trimmed) {
        return;
      }
      inputEl.value = '/m ' + trimmed + ': ';
      inputEl.focus();
    }
  });

  function appendMessages(html) {
    if (!html) {
      return;
    }
    const previousTop = messagesEl.scrollTop;
    const previousHeight = messagesEl.scrollHeight;

    const tmp = document.createElement('div');
    tmp.innerHTML = html;
    const children = Array.from(tmp.children);
    if (!children.length) {
      return;
    }

    // Build a set of existing message IDs so we can skip any duplicates that
    // arrive from overlapping poll/POST responses.
    const existingIds = {};
    const existingEls = messagesEl.querySelectorAll('[data-message-id]');
    existingEls.forEach((el) => {
      const rawId = el.getAttribute('data-message-id') || '';
      if (rawId) {
        existingIds[rawId] = true;
      }
    });

    // Insert new messages at the top (newest-first) while preserving order.
    for (let i = children.length - 1; i >= 0; i -= 1) {
      const child = children[i];
      const childId = child.getAttribute('data-message-id') || '';
      if (childId && Object.prototype.hasOwnProperty.call(existingIds, childId)) {
        continue;
      }
      if (messagesEl.firstChild) {
        messagesEl.insertBefore(child, messagesEl.firstChild);
      } else {
        messagesEl.appendChild(child);
      }
    }

    updateLastMessageIdFromDom();

    if (autoScrollTop) {
      messagesEl.scrollTop = 0;
    } else {
      const heightDiff = messagesEl.scrollHeight - previousHeight;
      messagesEl.scrollTop = Math.max(
        0,
        Math.min(messagesEl.scrollHeight, previousTop + heightDiff),
      );
    }
  }

  function loadChat() {
    if (isSelectionInsideMessages()) {
      // If the player is actively selecting/copying text, skip this poll so
      // we don't disrupt their selection.
      return;
    }

    let url = 'api/chat_api.php';
    const params = [];
    const sinceId = getSinceId();
    if (sinceId > 0) {
      params.push('last_id=' + encodeURIComponent(String(sinceId)));
    }
    if (!initialFetchDispatched) {
      params.push('initial=1');
      initialFetchDispatched = true;
    }
    if (params.length > 0) {
      url += '?' + params.join('&');
    }

    fetch(url, { credentials: 'same-origin' })
      .then((res) => {
        if (res.status === 401) {
          window.handlePossibleLogoutSignal();
          return '';
        }
        if (res.status === 429) {
          if (window.gameNotifications) {
            window.gameNotifications.show('Chat rate limit reached.');
          }
          return '';
        }
        return res.text();
      })
      .then((html) => {
        const trimmed = applyClearFilter(html.trim());
        if (!trimmed) {
          // No new messages. On the very first load, show a placeholder. On
          // incremental polls, leave the existing chat DOM untouched so that
          // text selections remain stable.
          maybePollHudState();
          if (lastMessageId === 0) {
            renderPlaceholder('No messages yet.');
          }
          return;
        }
        const lower = trimmed.toLowerCase();
        const hasEmailField =
          lower.indexOf('name=\"email\"') !== -1 ||
          lower.indexOf('name=\\\"email\\\"') !== -1;
        const hasPasswordField =
          lower.indexOf('type=\"password\"') !== -1 ||
          lower.indexOf('type=\\\"password\\\"') !== -1;
        if (html.indexOf('<title>Login</title>') !== -1 || (hasEmailField && hasPasswordField)) {
          window.handlePossibleLogoutSignal();
          return;
        }
        resetLogoutSignalCount();
        const isInitial = lastMessageId === 0;
        if (isInitial) {
          // Initial page load: render the full chat snapshot.
          renderMessages(trimmed);
          if (clearedThroughId > 0 && lastMessageId < clearedThroughId) {
            lastMessageId = clearedThroughId;
          }
        } else {
          // Incremental update: only append the new messages so we don't
          // wipe out selections or scroll position.
          appendMessages(trimmed);

          maybePollHudState();

          // If a PayPal auto-credit notification arrived, refresh the
          // player's HUD so Silver and other stats update without a
          // full page reload.
          if (
            typeof window.updatePlayerHud === 'function' &&
            trimmed.indexOf('Your purchase of') !== -1 &&
            trimmed.indexOf('Silver has been credited to your account!') !== -1
          ) {
            fetch('api/hud_state.php', { credentials: 'same-origin' })
              .then((res) => {
                if (!res.ok) return null;
                return res.json();
              })
              .then((data) => {
                if (!data || !data.success || !data.char) return;
                const c = data.char;
                window.updatePlayerHud({
                  hp: c.hp || 0,
                  max_hp: c.max_hp || 0,
                  gold: c.gold || 0,
                  silver: c.silver || 0,
                  exp: c.exp || 0,
                  exp_to_next: c.exp_to_next || 0,
                  level: c.level || 0,
                  stat_points: data.stat_points || 0,
                });
              })
              .catch(() => {
                // Swallow HUD refresh errors; chat is still updated.
              });
          }
        }
      })
      .catch(() => {
        /* swallow */
      });
  }

  function startPolling(intervalMs) {
    const nextInterval = intervalMs > 0 ? intervalMs : CHAT_POLL_INTERVAL_MS;
    if (pollTimer && pollIntervalMs === nextInterval) {
      return;
    }
    if (pollTimer) {
      clearInterval(pollTimer);
      pollTimer = null;
    }
    pollIntervalMs = nextInterval;
    loadChat();
    // Poll chat a bit faster for snappier updates.
    pollTimer = setInterval(loadChat, pollIntervalMs);
  }

  function stopPolling() {
    if (!pollTimer) {
      return;
    }
    clearInterval(pollTimer);
    pollTimer = null;
  }

  function handleVisibilityChange() {
    if (document.visibilityState === 'hidden') {
      startPolling(CHAT_HIDDEN_POLL_INTERVAL_MS);
      return;
    }
    startPolling(CHAT_POLL_INTERVAL_MS);
  }

  if (typeof document.visibilityState !== 'undefined') {
    document.addEventListener('visibilitychange', handleVisibilityChange);
  }
  handleVisibilityChange();

  formEl.addEventListener('submit', function handleSubmit(e) {
    e.preventDefault();
    const text = inputEl.value.trim();
    if (!text) {
      return;
    }

    // Prevent spamming the same message rapidly with Enter.
    const now = Date.now();
    if (isSending) {
      return;
    }
    if (text === lastMessage && now - lastSentAt < 2000) {
      return;
    }

    // Slash command handling (e.g., /wiki, /discord)
    const rawCommands = Array.isArray(window.chatCommands) ? window.chatCommands : [];
    const commandMap = {};
    rawCommands.forEach(function registerCommand(cmd) {
      if (!cmd || !cmd.name || !cmd.url_template) {
        return;
      }
      const key = String(cmd.name).toLowerCase();
      if (!key) {
        return;
      }
      commandMap[key] = {
        name: key,
        description: String(cmd.description || ''),
        urlTemplate: String(cmd.url_template),
      };
    });

    function tryHandleSlashCommand(inputText) {
      if (inputText.charAt(0) !== '/') {
        return false;
      }
      const withoutSlash = inputText.slice(1);
      if (!withoutSlash) {
        return false;
      }
      const parts = withoutSlash.split(/\s+/);
      const commandName = parts[0].toLowerCase();
      if (commandName === 'clear') {
        clearChatWindow();
        return true;
      }
      if (!commandName || !Object.prototype.hasOwnProperty.call(commandMap, commandName)) {
        return false;
      }
      const cmd = commandMap[commandName];
      const argText = withoutSlash.slice(commandName.length).trim();
      let url = cmd.urlTemplate;
      if (url.indexOf('{query}') !== -1) {
        const encoded = encodeURIComponent(argText);
        url = url.replace(/\{query\}/g, encoded);
      }
      if (!/^https?:\/\//i.test(url)) {
        if (window.gameNotifications) {
          window.gameNotifications.show('Invalid command URL.');
        }
        return true;
      }
      try {
        window.open(url, '_blank', 'noopener');
      } catch (err) {
        // ignore
      }
      return true;
    }

    if (tryHandleSlashCommand(text)) {
      inputEl.value = '';
      return;
    }

    isSending = true;
    lastMessage = text;
    lastSentAt = now;
    const isRcCommand = text.toLowerCase() === '/rc';
    const locationCard = document.getElementById('hud-location-card');
    const previousPlaneId = locationCard ? locationCard.dataset.planeId : '';

    const formData = new FormData();
    formData.append('message', text);
    formData.append('csrf_token', window.csrfToken || '');
    if (modeEl && modeEl.value) {
      formData.append('chat_mode', modeEl.value);
    }

    let postUrl = 'api/chat_api.php';
    const sinceId = getSinceId();
    if (sinceId > 0) {
      postUrl += '?last_id=' + encodeURIComponent(String(sinceId));
    }

    fetch(postUrl, {
      method: 'POST',
      body: formData,
      credentials: 'same-origin',
    })
      .then((res) => {
        if (res.status === 401) {
          if (window.gameNotifications) {
            window.gameNotifications.show('You have been logged out. Please refresh and log in again.');
          }
          return '';
        }
        if (res.status === 429) {
          if (window.gameNotifications) {
            window.gameNotifications.show('Chat rate limit reached.');
          }
          return '';
        }
        return res.text();
      })
      .then((html) => {
        inputEl.value = '';
        autoScrollTop = true;
        isSending = false;
        const trimmed = html ? html.trim() : '';
        if (!trimmed) {
          // If nothing new came back, leave the existing DOM (including
          // system banners) untouched.
          return;
        }
        // Always append new messages so system banners and earlier chat
        // lines are simply pushed down rather than being replaced.
        appendMessages(trimmed);
        if (isRcCommand) {
          forcePollHudState(previousPlaneId || '');
        } else {
          maybePollHudState();
        }
      })
      .catch(() => {
        isSending = false;
        /* swallow */
      });
  });
})();
