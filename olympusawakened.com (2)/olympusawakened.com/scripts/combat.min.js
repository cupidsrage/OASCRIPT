'use strict';

(function initCombatModule() {
  const selectEl = document.getElementById('monster-select');
  const buttonEl = document.getElementById('combat-main-button');
  const nameEl = document.getElementById('combat-monster-name');
  const hpTextEl = document.getElementById('combat-hp-text');
  const hpBarEl = document.getElementById('combat-hp-bar');
  const logEl = document.getElementById('combat-log');
  const placeholderEl = document.getElementById('combat-placeholder');
  const activeEl = document.getElementById('combat-active');
  const abilityEl = document.getElementById('combat-monster-ability');
  const revivePanel = document.getElementById('revive-panel');
  const reviveButton = document.getElementById('revive-button');
  const autoToggleEl = document.getElementById('auto-combat-toggle');
  const autoLabelEl = document.getElementById('auto-combat-label');
  const autoTooltipEl = document.getElementById('auto-combat-tooltip');
  const beastGroupEl = document.getElementById('beast-options-group');
  const playerAvatarEl = document.getElementById('combat-player-avatar');
  const opponentAvatarEl = document.getElementById('combat-enemy-avatar');
  const delayContainerEl = document.getElementById('combat-delay-indicator');
  const delayFillEl = document.getElementById('combat-delay-fill');
  const configHost = document.querySelector('[data-combat-config]');
  const botcheckModal = document.getElementById('botcheck-modal');
  const botcheckImageEl = document.querySelector('[data-botcheck-image]');
  const botcheckInputEl = document.querySelector('[data-botcheck-input]');
  const botcheckErrorEl = document.querySelector('[data-botcheck-error]');
  const botcheckSubmitEl = document.querySelector('[data-botcheck-submit]');
  const botcheckRefreshEl = document.querySelector('[data-botcheck-refresh]');
  const botcheckOverlayEl = document.querySelector('[data-botcheck-overlay]');
  const botcheckTimerEl = document.querySelector('[data-botcheck-timer]');
  const botcheckInstructionEl = document.querySelector('[data-botcheck-instruction]');

  if (!configHost) {
    return;
  }
  if (logEl) {
    logEl.classList.remove('hidden');
  }
  const enableHotkeysAttr =
    configHost.getAttribute('data-enable-combat-hotkeys');
  const enableHotkeys =
    enableHotkeysAttr === null || enableHotkeysAttr !== '0';

  function getActiveTabId() {
    const activeTabEl = document.querySelector(
      'a[data-active-tab="1"][data-tab-id]',
    );
    if (activeTabEl) {
      return activeTabEl.getAttribute('data-tab-id') || '';
    }
    try {
      const params = new URLSearchParams(window.location.search);
      return params.get('tab') || '';
    } catch (e) {
      return '';
    }
  }

  function isCombatTabActive() {
    return getActiveTabId() === 'combat';
  }

  let parsedConfig = {};
  try {
    const raw = configHost.getAttribute('data-combat-config') || '{}';
    parsedConfig = raw ? JSON.parse(raw) : {};
  } catch (err) {
    console.error('Invalid combat config payload', err);
    parsedConfig = {};
  }

  const formatInt =
    (window.App && typeof window.App.formatInt === 'function')
      ? window.App.formatInt
      : (value) => {
          const n = typeof value === 'number' && Number.isFinite(value)
            ? value
            : Number(value) || 0;
          return String(n);
        };

  let botcheckActive = false;
  let botcheckToken = '';
  let botcheckExpiresAt = 0;
  let botcheckTimerId = null;
  let botcheckTimeoutReported = false;
  let botcheckPromptType = 'full';
  let botcheckPromptPositions = [];
  let botcheckExpectedLength = 6;

  function normalizePromptPositions(value) {
    if (!value) return [];
    const parts = String(value)
      .split(',')
      .map((part) => part.trim())
      .filter(Boolean);
    const positions = [];
    for (const part of parts) {
      const pos = Number(part);
      if (!Number.isFinite(pos)) continue;
      const idx = Math.floor(pos);
      if (idx < 1 || idx > 6) continue;
      if (!positions.includes(idx)) {
        positions.push(idx);
      }
    }
    positions.sort((a, b) => a - b);
    return positions;
  }

  function applyBotcheckPromptState() {
    if (botcheckPromptType === 'subset' && botcheckPromptPositions.length > 0) {
      const last = botcheckPromptPositions.length - 1;
      const pretty = botcheckPromptPositions.length > 1
        ? botcheckPromptPositions.slice(0, last).join(', ') + ' and ' + botcheckPromptPositions[last]
        : String(botcheckPromptPositions[0]);
      botcheckExpectedLength = botcheckPromptPositions.length;
      if (botcheckInstructionEl) {
        botcheckInstructionEl.textContent =
          'Enter characters ' + pretty + ' from the code shown to continue fighting.';
      }
      if (botcheckInputEl) {
        botcheckInputEl.maxLength = botcheckExpectedLength;
        botcheckInputEl.placeholder = botcheckExpectedLength + '-character code';
        botcheckInputEl.setAttribute(
          'pattern',
          '[A-HJ-NP-Z2-9]{' + botcheckExpectedLength + '}',
        );
      }
      return;
    }
    botcheckPromptType = 'full';
    botcheckPromptPositions = [];
    botcheckExpectedLength = 6;
    if (botcheckInstructionEl) {
      botcheckInstructionEl.textContent =
        'Enter the 6-character code shown in the image to continue fighting.';
    }
    if (botcheckInputEl) {
      botcheckInputEl.maxLength = 6;
      botcheckInputEl.placeholder = '6-character code';
      botcheckInputEl.setAttribute('pattern', '[A-HJ-NP-Z2-9]{6}');
    }
  }

  function setBotcheckPrompt(prompt) {
    const type = prompt && typeof prompt.type === 'string'
      ? prompt.type.toLowerCase()
      : 'full';
    const positions = normalizePromptPositions(prompt && prompt.positions);
    botcheckPromptType = type === 'subset' ? 'subset' : 'full';
    botcheckPromptPositions = positions;
    applyBotcheckPromptState();
  }

  function refreshBotcheckImage() {
    if (!botcheckImageEl) return;
    if (!botcheckToken) {
      botcheckImageEl.removeAttribute('src');
      return;
    }
    if (botcheckExpiresAt && Date.now() > botcheckExpiresAt) {
      botcheckImageEl.removeAttribute('src');
      return;
    }
    const cacheBuster = Date.now();
    botcheckImageEl.src =
      'api/botcheck_image.php?token=' +
      encodeURIComponent(botcheckToken) +
      '&_=' +
      cacheBuster;
  }

  function updateBotcheckTimer() {
    if (!botcheckTimerEl || !botcheckExpiresAt) return;
    const remainingMs = botcheckExpiresAt - Date.now();
    const remaining = Math.max(0, Math.ceil(remainingMs / 1000));
    botcheckTimerEl.textContent = 'Time left: ' + remaining + 's';
    if (remaining <= 0) {
      if (botcheckTimerId) {
        clearInterval(botcheckTimerId);
        botcheckTimerId = null;
      }
      botcheckActive = false;
      if (!botcheckTimeoutReported) {
        botcheckTimeoutReported = true;
        reportBotcheckTimeout();
      }
      showNotification('Security check failed. Repeated failures will result in a logout.');
      hideBotcheck();
    }
  }

  async function reportBotcheckTimeout() {
    if (!botcheckToken) return;
    const fd = new FormData();
    fd.append('action', 'botcheck_timeout');
    fd.append('botcheck_token', botcheckToken);
    fd.append('csrf_token', window.csrfToken || '');
    try {
      const res = await fetch('api/combat_api.php', {
        method: 'POST',
        body: fd,
        credentials: 'same-origin',
      });
      const text = await res.text();
      let data = null;
      try {
        data = JSON.parse(text);
      } catch (e) {
        return;
      }
      if (handleTestingPhase1(data)) {
        return;
      }
      if (!data) return;
      if (data.error === 'botcheck_logout') {
        hideBotcheck();
        handleCombatLogout(data.notice || 'You have been logged out.');
      }
    } catch (err) {
      // Best-effort; timeout still counts server-side when action is next attempted.
    }
  }

  function showBotcheck(token, message, expiresIn) {
    if (!botcheckModal) return;
    botcheckActive = true;
    botcheckToken = token || botcheckToken;
    botcheckTimeoutReported = false;
    if (typeof expiresIn === 'number' && expiresIn > 0) {
      botcheckExpiresAt = Date.now() + expiresIn * 1000;
    }
    applyBotcheckPromptState();
    refreshBotcheckImage();
    if (botcheckInputEl) {
      botcheckInputEl.value = '';
      botcheckInputEl.focus();
    }
    if (botcheckErrorEl) {
      if (message) {
        botcheckErrorEl.textContent = message;
        botcheckErrorEl.classList.remove('hidden');
      } else {
        botcheckErrorEl.textContent = '';
        botcheckErrorEl.classList.add('hidden');
      }
    }
    if (botcheckTimerEl && botcheckExpiresAt) {
      updateBotcheckTimer();
      if (botcheckTimerId) {
        clearInterval(botcheckTimerId);
      }
      botcheckTimerId = setInterval(updateBotcheckTimer, 250);
    }
    botcheckModal.classList.remove('hidden');
    botcheckModal.classList.add('flex');
  }

  function hideBotcheck() {
    if (!botcheckModal) return;
    botcheckActive = false;
    botcheckToken = '';
    botcheckExpiresAt = 0;
    botcheckTimeoutReported = false;
    botcheckPromptType = 'full';
    botcheckPromptPositions = [];
    botcheckExpectedLength = 6;
    if (botcheckTimerId) {
      clearInterval(botcheckTimerId);
      botcheckTimerId = null;
    }
    if (botcheckErrorEl) {
      botcheckErrorEl.textContent = '';
      botcheckErrorEl.classList.add('hidden');
    }
    if (botcheckImageEl) {
      botcheckImageEl.removeAttribute('src');
    }
    botcheckModal.classList.add('hidden');
    botcheckModal.classList.remove('flex');
  }

  async function submitBotcheck() {
    if (!botcheckInputEl) return;
    const value = (botcheckInputEl.value || '').trim().toUpperCase();
    const length = botcheckExpectedLength > 0 ? botcheckExpectedLength : 6;
    const re = new RegExp('^[A-HJ-NP-Z2-9]{' + length + '}$');
    if (value !== '' && !re.test(value)) {
      showBotcheck(
        botcheckToken,
        botcheckPromptType === 'subset'
          ? 'Enter the requested characters from the code shown.'
          : 'Enter the 6-character code shown.',
      );
      return;
    }
    const fd = new FormData();
    fd.append('action', 'botcheck');
    fd.append('botcheck', value);
    fd.append('botcheck_token', botcheckToken || '');
    fd.append('csrf_token', window.csrfToken || '');
    try {
      const res = await fetch('api/combat_api.php', {
        method: 'POST',
        body: fd,
        credentials: 'same-origin',
      });
      const text = await res.text();
      let data = null;
      try {
        data = JSON.parse(text);
      } catch (e) {
        showBotcheck(botcheckToken, 'Unable to verify right now. Try again.');
        return;
      }
      if (data && data.error === 'botcheck_failed') {
        hideBotcheck();
        showNotification(data.notice || 'Security check failed.');
        return;
      }
      applyResponse(data, 'botcheck');
    } catch (err) {
      showBotcheck(botcheckToken, 'Unable to verify right now. Try again.');
    }
  }

  if (botcheckSubmitEl) {
    botcheckSubmitEl.addEventListener('click', submitBotcheck);
  }
  if (botcheckRefreshEl) {
    botcheckRefreshEl.addEventListener('click', () => {
      if (!botcheckActive) return;
      refreshBotcheckImage();
    });
  }
  if (botcheckInputEl) {
    botcheckInputEl.addEventListener('input', () => {
      const raw = botcheckInputEl.value || '';
      const maxLen = botcheckExpectedLength > 0 ? botcheckExpectedLength : 6;
      const cleaned = raw.toUpperCase().replace(/[^A-HJ-NP-Z2-9]/g, '').slice(0, maxLen);
      if (cleaned !== raw) {
        botcheckInputEl.value = cleaned;
      }
    });
    botcheckInputEl.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        submitBotcheck();
      }
    });
  }
  if (botcheckOverlayEl) {
    botcheckOverlayEl.addEventListener('click', (event) => {
      if (event.target === botcheckOverlayEl) {
        if (botcheckInputEl) {
          botcheckInputEl.focus();
        }
      }
    });
  }

  function normalizeMonsterId(value) {
    if (value === undefined || value === null) {
      return null;
    }
    const str = String(value).trim();
    return str === '' ? null : str;
  }

  let domLastSelectedId = normalizeMonsterId(
    selectEl ? selectEl.getAttribute('data-last-selected') : null,
  );

  const playerIdForStorage = normalizeMonsterId(parsedConfig.playerId);
  const planeIdForStorage = normalizeMonsterId(parsedConfig.planeId);
  const lastMonsterStorageKey = playerIdForStorage
    ? 'combat:last_monster:' + playerIdForStorage
    : null;
  const lastMonsterPlaneKey = playerIdForStorage
    ? 'combat:last_monster_plane:' + playerIdForStorage
    : null;

  function readStoredMonsterId() {
    if (
      !lastMonsterStorageKey ||
      typeof window === 'undefined' ||
      !window.localStorage
    ) {
      return null;
    }
    try {
      const value = window.localStorage.getItem(lastMonsterStorageKey);
      if (!value) {
        return null;
      }
      if (lastMonsterPlaneKey && planeIdForStorage) {
        const storedPlane = window.localStorage.getItem(lastMonsterPlaneKey);
        if (!storedPlane || storedPlane !== planeIdForStorage) {
          return null;
        }
      }
      const trimmed = value.trim();
      return trimmed === '' ? null : trimmed;
    } catch (err) {
      return null;
    }
  }

  let cachedLastMonsterId = readStoredMonsterId();

  function persistLastMonsterId(value) {
    const normalized = normalizeMonsterId(value);
    cachedLastMonsterId = normalized;
    if (
      !lastMonsterStorageKey ||
      typeof window === 'undefined' ||
      !window.localStorage
    ) {
      return;
    }
    try {
      if (normalized) {
        window.localStorage.setItem(lastMonsterStorageKey, normalized);
        if (lastMonsterPlaneKey && planeIdForStorage) {
          window.localStorage.setItem(lastMonsterPlaneKey, planeIdForStorage);
        }
      } else {
        window.localStorage.removeItem(lastMonsterStorageKey);
        if (lastMonsterPlaneKey) {
          window.localStorage.removeItem(lastMonsterPlaneKey);
        }
      }
    } catch (err) {
      /* ignore storage errors */
    }
  }

  const initialActionDelayMs =
    typeof parsedConfig.actionDelayMs === 'number'
      ? parsedConfig.actionDelayMs
      : Number(parsedConfig.actionDelayMs) || 0;
  const fallbackActionDelayMs =
    typeof parsedConfig.defaultDelayMs === 'number'
      ? parsedConfig.defaultDelayMs
      : Number(parsedConfig.defaultDelayMs) || 3000;
  const initialNextActionTs =
    parsedConfig.nextActionTs !== undefined &&
    parsedConfig.nextActionTs !== null &&
    !Number.isNaN(Number(parsedConfig.nextActionTs))
      ? Number(parsedConfig.nextActionTs)
      : null;
  const initialNextActionTsMs =
    parsedConfig.nextActionTsMs !== undefined &&
    parsedConfig.nextActionTsMs !== null &&
    !Number.isNaN(Number(parsedConfig.nextActionTsMs))
      ? Number(parsedConfig.nextActionTsMs)
      : null;

  const autoConfig =
    parsedConfig && parsedConfig.autoCombat && typeof parsedConfig.autoCombat === 'object'
      ? parsedConfig.autoCombat
      : {};
  const autoAvailable =
    !!autoConfig.unlocked && (autoConfig.enabled === undefined || autoConfig.enabled !== false);
  const autoMaxMinutes =
    typeof autoConfig.maxMinutes === 'number'
      ? autoConfig.maxMinutes
      : Number(autoConfig.maxMinutes) || 0;
  const autoMaxDeaths =
    typeof autoConfig.maxDeaths === 'number'
      ? autoConfig.maxDeaths
      : Number(autoConfig.maxDeaths) || 0;
  const autoDailyLimitMinutes =
    typeof autoConfig.dailyLimitMinutes === 'number'
      ? autoConfig.dailyLimitMinutes
      : Number(autoConfig.dailyLimitMinutes) || 0;
  const autoDailyRemainingSeconds =
    typeof autoConfig.dailyRemainingSeconds === 'number'
      ? autoConfig.dailyRemainingSeconds
      : Number(autoConfig.dailyRemainingSeconds);
  const isTournamentPlane =
    parsedConfig && parsedConfig.isTournamentPlane === true;

  const initialLastMonsterId = isTournamentPlane
    ? null
    : normalizeMonsterId(parsedConfig.lastMonsterId) || cachedLastMonsterId;

  const state = {
    inCombat: Boolean(parsedConfig.inCombat),
    currentMonsterId:
      parsedConfig.currentMonsterId !== undefined
        ? parsedConfig.currentMonsterId
        : null,
    lastMonsterId: initialLastMonsterId,
    playerHp: Number(parsedConfig.playerHp) || 0,
    playerMaxHp: Number(parsedConfig.playerMaxHp) || 0,
    playerGold: Number(parsedConfig.playerGold) || 0,
    playerSilver: Number(parsedConfig.playerSilver) || 0,
    playerExp: Number(parsedConfig.playerExp) || 0,
    playerExpToNext: Number(parsedConfig.playerExpToNext) || 0,
    playerLevel: Number(parsedConfig.playerLevel) || 0,
    statPoints: Number(parsedConfig.statPoints) || 0,
    abilityName: parsedConfig.abilityName || '',
    abilityDesc: parsedConfig.abilityDesc || '',
    canAttack: true,
    actionDelayMs:
      initialActionDelayMs > 0 ? initialActionDelayMs : fallbackActionDelayMs,
    nextActionReadyAt: 0,
    delayActive: false,
    beasts: Array.isArray(parsedConfig.beasts) ? parsedConfig.beasts : [],
    autoAvailable,
    autoMode: false,
    autoMaxMinutes: autoMaxMinutes > 0 ? autoMaxMinutes : 0,
    autoMaxDeaths: autoMaxDeaths > 0 ? autoMaxDeaths : 0,
    autoDailyLimitMinutes: autoDailyLimitMinutes > 0 ? autoDailyLimitMinutes : 0,
    autoDailyRemainingSeconds: Number.isFinite(autoDailyRemainingSeconds)
      ? autoDailyRemainingSeconds
      : null,
    autoStartedAt: 0,
    autoKillCount: 0,
    autoDeathCount: 0,
    isTournamentPlane: isTournamentPlane,
  };
  let actionInFlight = false;
  if (state.lastMonsterId) {
    persistLastMonsterId(state.lastMonsterId);
  }

  // Expose combat HUD state so other UI (like the stat allocation modal)
  // can keep stat point totals in sync with the latest server values.
  window.CombatState = window.CombatState || state;
  window.AutoCombat = window.AutoCombat || {};
  window.AutoCombat.isRunning = !!state.autoMode;

  if (parsedConfig && parsedConfig.avatars) {
    updateAvatarDisplay(parsedConfig.avatars, null);
  }

  const BEAST_POLL_INTERVAL = 2500;
  const BEAST_POLL_HIDDEN_INTERVAL = 15000;
  const PVP_POLL_INTERVAL = 600;
  const PVP_POLL_HIDDEN_INTERVAL = 10000;
  const VISIBLE_LOG_LINES = 6;
  let cooldownTimer = null;
  let beastPollTimer = null;
  let delayTicker = null;
  let lastDelayPct = 0;
  let cooldownLocalOnly = false;
  let selectGuardTimer = null;
  let pendingBeastOptions = null;
  const selectInteraction = {
    isOpen: false,
    suppressUntil: 0,
  };
  let pvpPollTimer = null;
  let pvpPollInterval = 0;
  let beastPollInterval = 0;

  function isSelectBusy() {
    if (!selectEl) return false;
    if (selectInteraction.isOpen) return true;
    return Date.now() < selectInteraction.suppressUntil;
  }

  function isPageVisible() {
    return typeof document.visibilityState === 'undefined'
      || document.visibilityState !== 'hidden';
  }

  function deferBeastOptions(beasts) {
    pendingBeastOptions = beasts;
  }

  function flushBeastOptions() {
    if (!pendingBeastOptions) return;
    const beasts = pendingBeastOptions;
    pendingBeastOptions = null;
    renderBeastOptions(beasts);
    updateAbilityFromSelect();
  }

  function updateHeaderHud() {
    if (typeof window.updatePlayerHud === 'function') {
      window.updatePlayerHud({
        hp: state.playerHp || 0,
        max_hp: state.playerMaxHp || 0,
        gold: state.playerGold || 0,
        silver: state.playerSilver || 0,
        exp: state.playerExp || 0,
        exp_to_next: state.playerExpToNext || 0,
        level: state.playerLevel || 0,
        stat_points: state.statPoints || 0,
      });
    }
  }

  function getDelayDurationMs() {
    const parsed = Number(state.actionDelayMs) || 0;
    if (parsed > 0) {
      return parsed;
    }
    return fallbackActionDelayMs;
  }

  function setDelayFillWidth(percent, instant = false) {
    if (!delayFillEl) return;
    let clamped = Math.max(0, Math.min(100, percent));
    if (!instant) {
      // Ensure the bar never grows back during a cooldown; only shrink or stay.
      clamped = Math.min(clamped, lastDelayPct || clamped);
    }
    lastDelayPct = clamped;
    if (instant) {
      delayFillEl.style.transition = 'none';
    }
    delayFillEl.style.width = clamped + '%';
    delayFillEl.style.opacity = clamped > 0 ? '1' : '0';
    if (instant) {
      // Force reflow so the next width change animates again.
      // eslint-disable-next-line no-unused-expressions
      delayFillEl.offsetHeight;
      delayFillEl.style.transition = '';
    }
  }

  function renderDelayIndicator(forceInstant = false) {
    if (!delayContainerEl || !delayFillEl) {
      return false;
    }
    const delayMs = getDelayDurationMs();
    const readyAt = Number(state.nextActionReadyAt || 0);
    const now = Date.now();
    const remaining = readyAt > now ? readyAt - now : 0;
    const isDraining = delayMs > 0 && remaining > 0;
    state.delayActive = isDraining;
    const pct = isDraining
      ? Math.max(0, Math.min(100, (remaining / delayMs) * 100))
      : 0;
    setDelayFillWidth(isDraining ? pct : 0, forceInstant);
    if (delayContainerEl) {
      delayContainerEl.style.opacity = isDraining ? '1' : '0.35';
      delayContainerEl.classList.remove('hidden');
    }
    updateReviveButtonDisabled();
    updateMainButtonDisabled();
    toggleCombatDisplay(state.inCombat || state.delayActive);
    return isDraining;
  }

  function ensureDelayTicker() {
    if (!delayFillEl || delayTicker) return;
    delayTicker = setInterval(() => {
      const active = renderDelayIndicator();
      if (!active) {
        stopDelayTicker();
      }
    }, 75);
  }

  function stopDelayTicker() {
    if (delayTicker) {
      clearInterval(delayTicker);
      delayTicker = null;
    }
  }

  function syncDelayFromPayload(payload, sourceAction) {
    if (!payload) {
      renderDelayIndicator();
      return;
    }

    const isDeath = (state.playerHp || 0) <= 0;
    const forceServerCooldown =
      payload && payload.force_server_cooldown ? true : false;
    const hintedRemaining = Number(payload.remaining_ms);

    // When we started a local cooldown for a fight action, ignore server timing
    // corrections for that same action to avoid visible jumps in the bar.
    // However, on death we must always honor the server-enforced minimum cooldown
    // (e.g. 5000ms) even if it would lengthen the bar.
    if (!isDeath && !forceServerCooldown && cooldownLocalOnly && sourceAction === 'fight') {
      const localRemainingHint =
        state.nextActionReadyAt && state.nextActionReadyAt > Date.now()
          ? state.nextActionReadyAt - Date.now()
          : 0;
      const shouldHonorServer =
        !Number.isNaN(hintedRemaining) &&
        hintedRemaining > localRemainingHint + 500;
      if (shouldHonorServer) {
        cooldownLocalOnly = false;
      } else {
        const duration = Number(
          payload.duration_ms !== undefined
            ? payload.duration_ms
            : payload.action_delay_ms,
        );
        if (!Number.isNaN(duration) && duration > 0) {
          state.actionDelayMs = duration;
        }
        return;
      }
    }

    const wasActive = state.delayActive;
    const duration = Number(
      payload.duration_ms !== undefined
        ? payload.duration_ms
        : payload.action_delay_ms,
    );
    const looksLikePenaltyCooldown =
      !Number.isNaN(duration) &&
      duration > 0 &&
      !Number.isNaN(hintedRemaining) &&
      hintedRemaining > 0 &&
      Math.abs(duration - hintedRemaining) <= 300;
    let remaining = Number(payload.remaining_ms);
    if (Number.isNaN(remaining) || remaining < 0) {
      const readyAtMs = Number(
        payload.ready_at_ms !== undefined
          ? payload.ready_at_ms
          : payload.next_action_ts_ms !== undefined
            ? payload.next_action_ts_ms
            : payload.next_action_ts !== undefined
              ? Number(payload.next_action_ts) * 1000
              : 0,
      );
      if (readyAtMs > 0) {
        const serverNow = Number(payload.server_time_ms);
        const now = Date.now();
        remaining =
          !Number.isNaN(serverNow) && serverNow > 0
            ? readyAtMs - serverNow
            : readyAtMs - now;
      }
    }
    if (!isDeath && !forceServerCooldown) {
      const localRemaining =
        state.nextActionReadyAt && state.nextActionReadyAt > Date.now()
          ? state.nextActionReadyAt - Date.now()
          : 0;
      if (!Number.isNaN(localRemaining) && localRemaining > 0) {
        if (Number.isNaN(remaining) || remaining <= 0) {
          // If the server didn't give us a usable remaining value, fall back to the local timer.
          remaining = localRemaining;
        } else {
          if (looksLikePenaltyCooldown) {
            // Security/rate-limit cooldowns should override a shorter local bar.
            remaining = Math.max(remaining, localRemaining);
            cooldownLocalOnly = false;
          } else {
            // Never lengthen the cooldown bar once it has started draining; this avoids a visible "jump back".
            remaining = Math.min(remaining, localRemaining);
          }
        }
      }
    } else {
      // On death, always honor the server cooldown and stop treating this as a local-only timer.
      cooldownLocalOnly = false;
    }

    if (!Number.isNaN(duration) && duration > 0) {
      let nextDuration = duration;
      const looksLikeRemainingSnapshot =
        !Number.isNaN(remaining) &&
        remaining > 0 &&
        duration <= remaining + 250;
      if (
        wasActive &&
        looksLikeRemainingSnapshot &&
        Number(state.actionDelayMs) > 0 &&
        duration < Number(state.actionDelayMs)
      ) {
        // Keep the cooldown denominator stable while draining so the bar
        // doesn't visually "hang" near full on repeated server syncs.
        nextDuration = Number(state.actionDelayMs);
      }
      if (!Number.isNaN(remaining) && remaining > 0 && nextDuration < remaining) {
        nextDuration = remaining;
      }
      state.actionDelayMs = nextDuration;
    }

    if (Number.isNaN(remaining) || remaining <= 0) {
      state.nextActionReadyAt = 0;
      state.delayActive = false;
      state.canAttack = true;
      if (cooldownTimer) {
        clearTimeout(cooldownTimer);
        cooldownTimer = null;
      }
      stopDelayTicker();
      renderDelayIndicator();
      toggleCombatDisplay(state.inCombat || state.delayActive);
      maybeHandleAutoReady();
      return;
    }
    const localReady = Date.now() + remaining;
    state.nextActionReadyAt = localReady;
    state.delayActive = true;
    state.canAttack = false;
    if (cooldownTimer) {
      clearTimeout(cooldownTimer);
    }
    cooldownTimer = setTimeout(() => {
      state.canAttack = true;
      cooldownTimer = null;
      state.nextActionReadyAt = 0;
      state.delayActive = false;
      renderDelayIndicator(true);
      stopDelayTicker();
      toggleCombatDisplay(state.inCombat || state.delayActive);
      maybeHandleAutoReady();
    }, remaining);
    ensureDelayTicker();
    // Snap to the correct percentage when syncing with the server to avoid a visible jump.
    renderDelayIndicator(true);
    toggleCombatDisplay(state.delayActive || state.inCombat);
  }

  function beginCooldown(durationOverride) {
    const baseDelay = getDelayDurationMs();
    const delay =
      typeof durationOverride === 'number' && durationOverride > 0
        ? durationOverride
        : baseDelay;
    state.canAttack = false;
    state.delayActive = true;
    // Start at full bar immediately; when syncDelayFromPayload runs for this
    // fight, we keep using the local timer so the bar never "jumps back".
    setDelayFillWidth(100, true);
    cooldownLocalOnly = true;
    const readyAt = Date.now() + delay;
    state.nextActionReadyAt = readyAt;
    if (cooldownTimer) {
      clearTimeout(cooldownTimer);
    }
    cooldownTimer = setTimeout(() => {
      state.canAttack = true;
      cooldownTimer = null;
      state.nextActionReadyAt = 0;
      state.delayActive = false;
      cooldownLocalOnly = false;
      renderDelayIndicator(true);
      stopDelayTicker();
      toggleCombatDisplay(state.inCombat || state.delayActive);
      maybeHandleAutoReady();
    }, delay);
    renderDelayIndicator(true);
    ensureDelayTicker();
    toggleCombatDisplay(state.inCombat || state.delayActive);
  }

  // Start a cooldown for non-combat actions (e.g. map movement)
  // while still using the shared delay bar UI.
  function beginExternalCooldown(durationOverride) {
    const baseDelay = getDelayDurationMs();
    const delay =
      typeof durationOverride === 'number' && durationOverride > 0
        ? durationOverride
        : baseDelay;
    state.canAttack = false;
    state.delayActive = true;
    setDelayFillWidth(100, true);
    const readyAt = Date.now() + delay;
    state.nextActionReadyAt = readyAt;
    if (cooldownTimer) {
      clearTimeout(cooldownTimer);
    }
    cooldownTimer = setTimeout(() => {
      state.canAttack = true;
      cooldownTimer = null;
      state.nextActionReadyAt = 0;
      state.delayActive = false;
      renderDelayIndicator(true);
      stopDelayTicker();
      toggleCombatDisplay(state.inCombat || state.delayActive);
    }, delay);
    renderDelayIndicator(true);
    ensureDelayTicker();
    toggleCombatDisplay(state.inCombat || state.delayActive);
  }

  function getSelectedMonsterId() {
    if (!selectEl) return '';
    return selectEl.value || '';
  }

  function updateMainButtonLabel() {
    if (!buttonEl) return;
    let label = 'Start (F)';
    if (state.isTournamentPlane) {
      label = state.inCombat ? 'Attack (A)' : 'Start (F)';
      buttonEl.textContent = label;
      return;
    }
    if (state.inCombat) {
      const selectedId = getSelectedMonsterId();
      const currentId =
        state.currentMonsterId !== null ? String(state.currentMonsterId) : '';
      if (selectedId && selectedId !== currentId) {
        label = 'Switch Target';
      } else {
        const isPvpTarget =
          currentId && typeof currentId === 'string'
            ? currentId.indexOf('player:') === 0
            : false;
        label = isPvpTarget ? 'Duel Attack (A)' : 'Attack (A)';
      }
    }
    buttonEl.textContent = label;
  }

  function escapeHtml(str) {
    const text = str !== undefined && str !== null ? String(str) : '';
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
  }

  function setAbilityText(name, desc) {
    if (!abilityEl) return;
    const cleanName = escapeHtml(name || '');
    const cleanDesc = escapeHtml(desc || '');
    if (cleanName) {
      abilityEl.innerHTML =
        '<span class="text-purple-300 font-semibold">' +
        cleanName +
        ':</span> ' +
        '<span>' +
        (cleanDesc || 'Special trait') +
        '</span>';
    } else {
      abilityEl.innerHTML =
        '<span class="text-gray-500">No special ability.</span>';
    }
  }

  function updateMonsterOptionLabels(rarity) {
    if (!selectEl) return;
    const normalized =
      typeof rarity === 'string' ? rarity.toLowerCase().trim() : '';
    const hasPrefix = normalized === 'elite' || normalized === 'rare';
    const prefix = hasPrefix
      ? normalized.charAt(0).toUpperCase() + normalized.slice(1) + ' | '
      : '';
    const options = Array.from(selectEl.options || []);
    options.forEach((opt) => {
      if (!opt || !opt.dataset || opt.dataset.monsterOption !== '1') {
        return;
      }
      const baseName = opt.dataset.monsterName || '';
      const level = opt.dataset.monsterLevel || '';
      let label = baseName;
      if (prefix) {
        label = prefix + label;
      }
      if (level !== '') {
        label += ' (Lvl ' + level + ')';
      }
      opt.textContent = label;
    });
  }

  function updateAbilityFromSelect() {
    if (!selectEl || state.inCombat) return;
    // When the player is dead, do not show any monster ability preview.
    if ((state.playerHp || 0) <= 0) {
      setAbilityText('', '');
      return;
    }
    const opt = selectEl.options[selectEl.selectedIndex];
    if (!opt || !opt.value) {
      if (abilityEl) {
        abilityEl.innerHTML =
          '<span class="text-gray-500">Select a monster to view its ability.</span>';
      }
      return;
    }
    setAbilityText(
      opt.getAttribute('data-ability-name') || '',
      opt.getAttribute('data-ability-desc') || '',
    );
  }

  function updateAvatarSlot(slotEl, payload, label) {
    if (!slotEl) return;
    const img = slotEl.querySelector('[data-avatar-image]');
    const fallback = slotEl.querySelector('[data-avatar-fallback]');
    const name = slotEl.querySelector('[data-avatar-name]');
    const src =
      payload &&
      (payload.src || payload.image_path || '').toString().trim();
    const showSetting = !!(payload && payload.show_setting);
    const hasAvatar = !!(payload && payload.has_avatar);
    const show = showSetting && hasAvatar && src !== '';

    if (name && label) {
      name.textContent = label;
    }
    slotEl.classList.toggle('oa-avatar-card--off', !showSetting);
    slotEl.classList.toggle('oa-avatar-card--empty', showSetting && !hasAvatar);
    if (img) {
      if (show) {
        img.src = src;
        img.alt = payload.name || label || 'Avatar';
        img.classList.remove('hidden');
      } else {
        img.classList.add('hidden');
      }
    }
    if (fallback) {
      fallback.classList.toggle('hidden', showSetting && hasAvatar);
    }
  }

  function updateAvatarDisplay(avatars, combatData) {
    if (!avatars) return;
    updateAvatarSlot(playerAvatarEl, avatars.player, 'You');
    const opponentLabel =
      (combatData && combatData.monster_name) ||
      (avatars.opponent && avatars.opponent.display_name) ||
      'Opponent';
    const opponentPayload = avatars.is_pvp ? avatars.opponent : null;
    updateAvatarSlot(opponentAvatarEl, opponentPayload, opponentLabel);
  }

  function ensureCurrentMonsterVisible(combatData) {
    if (!selectEl || !state.currentMonsterId) return;
    const value = String(state.currentMonsterId);
    const options = Array.from(selectEl.options || []);
    const existing = options.find((opt) => opt.value === value);
    if (existing) {
      selectEl.value = value;
      if (combatData) {
        existing.setAttribute(
          'data-ability-name',
          combatData.ability_name || '',
        );
        existing.setAttribute(
          'data-ability-desc',
          combatData.ability_desc || '',
        );
      }
      return;
    }
    let temp = selectEl.querySelector('option[data-temp-current="1"]');
    if (!temp) {
      temp = document.createElement('option');
      temp.setAttribute('data-temp-current', '1');
      const insertBefore =
        selectEl.options.length > 1 ? selectEl.options[1] : null;
      selectEl.insertBefore(temp, insertBefore);
    }
    const labelParts = [];
    if (combatData && combatData.monster_name) {
      labelParts.push(combatData.monster_name);
    } else {
      labelParts.push('Current Enemy');
    }
    if (combatData && combatData.monster_level !== undefined) {
      labelParts.push('(Lvl ' + combatData.monster_level + ')');
    }
    temp.value = value;
    temp.textContent = labelParts.join(' ');
    temp.setAttribute(
      'data-ability-name',
      (combatData && combatData.ability_name) || '',
    );
    temp.setAttribute(
      'data-ability-desc',
      (combatData && combatData.ability_desc) || '',
    );
    selectEl.value = value;
  }

  function clearTemporaryMonsterOption() {
    if (!selectEl) return;
    const temp = selectEl.querySelector('option[data-temp-current="1"]');
    if (temp) {
      temp.remove();
    }
  }

  function resolvePreferredMonsterId(preferredValue) {
    return (
      normalizeMonsterId(preferredValue) ||
      normalizeMonsterId(state.lastMonsterId) ||
      domLastSelectedId ||
      cachedLastMonsterId
    );
  }

  function setMonsterSelectValue(preferredValue) {
    if (!selectEl) return false;
    const targetValue = resolvePreferredMonsterId(preferredValue);
    const previous = selectEl.value || '';
    let matched = false;
    if (targetValue) {
      const target = String(targetValue);
      const options = Array.from(selectEl.options || []);
      for (let i = 0; i < options.length; i += 1) {
        const opt = options[i];
        if (opt.value === target) {
          opt.selected = true;
          opt.setAttribute('selected', 'selected');
          selectEl.selectedIndex = i;
          selectEl.value = target;
          matched = true;
        } else {
          opt.selected = false;
          opt.removeAttribute('selected');
        }
      }
      if (matched) {
        state.lastMonsterId = target;
        persistLastMonsterId(target);
        domLastSelectedId = target;
        if (selectEl) {
          selectEl.setAttribute('data-last-selected', target);
        }
        if (previous !== target) {
          selectEl.dispatchEvent(new Event('change', { bubbles: true }));
        }
        return true;
      }
    }
    if (previous !== '') {
      selectEl.selectedIndex = 0;
      selectEl.value = '';
      Array.from(selectEl.options || []).forEach((opt, idx) => {
        if (idx === 0) {
          opt.selected = true;
          opt.setAttribute('selected', 'selected');
        } else {
          opt.selected = false;
          opt.removeAttribute('selected');
        }
      });
      selectEl.dispatchEvent(new Event('change', { bubbles: true }));
    }
    return false;
  }

  const LOG_TYPE_CLASSES = {
    start: 'text-purple-300 font-semibold',
    'beast-start': 'text-purple-200 font-semibold',
    warning: 'text-yellow-300 font-semibold',
    artifact: 'text-blue-300',
    'player-critical': 'text-red-400 font-semibold',
    'player-spell-critical': 'text-blue-300 font-semibold',
    'player-attack': 'text-blue-200',
    'player-hit': 'text-blue-200',
    'player-ranged-hit': 'text-blue-200',
    'player-spell-hit': 'text-blue-200',
    'player-hit-mixed': 'text-blue-200',
    'player-miss': 'text-gray-300',
    'player-miss-spell': 'text-gray-300 italic',
    'player-miss-phys': 'text-gray-300 italic',
    'player-dodge': 'text-yellow-300 font-semibold',
    'player-regen': 'text-green-300 font-semibold',
    'player-defeat': 'text-red-500 font-semibold',
    'player-heal': 'text-green-300 font-semibold',
    'monster-hit': 'text-pink-200',
    'monster-miss': 'text-pink-200',
    'pvp-miss': 'text-pink-200',
    'pvp-player-miss': 'text-pink-200',
    'pvp-phys-hit': 'text-pink-200',
    'pvp-spell-hit': 'text-pink-200',
    'pvp-mixed-hit': 'text-pink-200',
    'pvp-ranged-hit': 'text-pink-200',
    'monster-ability': 'text-orange-300 italic',
    'monster-regen': 'text-green-300 italic',
    'monster-defeated': 'text-green-300 font-semibold',
    loot: 'text-amber-200',
    currency: 'text-yellow-300 font-semibold',
    'loot-summary': 'text-yellow-200',
    levelup: 'text-green-300 font-semibold',
    'spell-bonus': 'text-indigo-300 font-semibold',
    'spell-heal': 'text-green-200',
    'player-victory': 'text-green-300 font-semibold',
    neutral: 'text-gray-200',
  };

  if (
    parsedConfig &&
    parsedConfig.logTypeClasses &&
    typeof parsedConfig.logTypeClasses === 'object'
  ) {
    Object.keys(parsedConfig.logTypeClasses).forEach((key) => {
      const value = parsedConfig.logTypeClasses[key];
      if (typeof value === 'string' && value.trim() !== '') {
        LOG_TYPE_CLASSES[key] = value;
      }
    });
  }

  function getLogEntryText(entry) {
    if (
      entry &&
      typeof entry === 'object' &&
      entry.text !== undefined &&
      entry.text !== null
    ) {
      return String(entry.text);
    }
    if (entry !== undefined && entry !== null) {
      return String(entry);
    }
    return '';
  }

  function getLogEntryType(entry) {
    if (entry && typeof entry === 'object' && entry.type) {
      return String(entry.type);
    }
    return 'neutral';
  }

  function getLogLineClass(entry) {
    const type = entry && typeof entry === 'object' ? entry.type || '' : '';
    if (type && LOG_TYPE_CLASSES[type]) {
      return LOG_TYPE_CLASSES[type];
    }
    const lower = getLogEntryText(entry).toLowerCase();
    if (lower.includes('crit')) {
      return LOG_TYPE_CLASSES['player-critical'];
    }
    if (lower.includes('you were defeated') || lower.includes('defeated!')) {
      return LOG_TYPE_CLASSES['player-defeat'];
    }
    if (lower.includes('dodg')) {
      return LOG_TYPE_CLASSES['player-dodge'];
    }
    if (lower.includes('defeated')) {
      return LOG_TYPE_CLASSES['monster-defeated'];
    }
    if (
      lower.includes('surge') ||
      lower.includes('bonus damage') ||
      lower.includes('erupts')
    ) {
      return LOG_TYPE_CLASSES['spell-bonus'];
    }
    if (lower.includes('restores') || lower.includes('heals') || lower.includes('regenerat')) {
      return (
        LOG_TYPE_CLASSES['spell-heal'] || LOG_TYPE_CLASSES['player-heal']
      );
    }
    if (lower.includes('you miss')) {
      return LOG_TYPE_CLASSES['player-miss'] || LOG_TYPE_CLASSES.neutral;
    }
    if (lower.includes('revive')) {
      return LOG_TYPE_CLASSES.warning;
    }
    if (lower.includes('you hit') || lower.includes('you crit')) {
      return LOG_TYPE_CLASSES['player-attack'];
    }
    if (lower.includes('hits for') || lower.includes('hit for')) {
      return LOG_TYPE_CLASSES['monster-hit'];
    }
    if (lower.includes('exp') || lower.includes('level up')) {
      return LOG_TYPE_CLASSES.levelup;
    }
    return LOG_TYPE_CLASSES.neutral;
  }

  function isAutoBlockedTargetId(id) {
    if (id === undefined || id === null) return false;
    const value = String(id);
    if (!value) return false;
    if (value.startsWith('beast:')) return true;
    if (value.startsWith('player:')) return true;
    return false;
  }

  function autoBlockedTargetMessage(id) {
    if (id === undefined || id === null) return 'Auto-combat stopped: invalid target.';
    const value = String(id);
    if (value.startsWith('beast:')) {
      return 'Auto-combat stopped: Beasts are not eligible targets.';
    }
    if (value.startsWith('player:')) {
      return 'Auto-combat stopped: Players are not eligible targets.';
    }
    return 'Auto-combat stopped: invalid target.';
  }

  function isSelectableTargetId(id) {
    if (!selectEl) return false;
    if (id === undefined || id === null) return false;
    const value = String(id);
    if (!value) return false;
    const options = Array.from(selectEl.options || []);
    return options.some((opt) => opt.value === value);
  }

  function hasValidAutoTargetSelection() {
    const selectedId = getSelectedMonsterId();
    if (!selectedId) return false;
    if (isAutoBlockedTargetId(selectedId)) return false;
    return isSelectableTargetId(selectedId);
  }

  async function logAutoCombatEvent(event, reason) {
    if (!event) return;
    try {
      const fd = new FormData();
      fd.append('event', String(event));
      if (reason) {
        fd.append('reason', String(reason));
      }
      fd.append('csrf_token', window.csrfToken || '');
      await fetch('api/auto_combat_log.php', {
        method: 'POST',
        body: fd,
        credentials: 'same-origin',
      });
    } catch (e) {
      // Logging failures should not interfere with gameplay.
    }
  }

  function updateAutoToggleLabel() {
    if (!autoToggleEl) return;
    const isOn = !!state.autoMode;
    if (autoLabelEl) {
      autoLabelEl.textContent = isOn ? 'Auto: On' : 'Auto: Off';
    }
    autoToggleEl.classList.toggle('bg-green-700', isOn);
    autoToggleEl.classList.toggle('hover:bg-green-600', isOn);
    autoToggleEl.classList.toggle('bg-gray-700', !isOn);
    autoToggleEl.classList.toggle('hover:bg-gray-600', !isOn);
    autoToggleEl.classList.toggle('opacity-50', !state.autoAvailable);
    autoToggleEl.classList.toggle('cursor-not-allowed', !state.autoAvailable);
    if (autoTooltipEl) {
      if (state.autoAvailable) {
        const limitMinutes = Number(state.autoDailyLimitMinutes || 0);
        const maxDeaths = Number(state.autoMaxDeaths || 0);
        let timeLabel = '--:--';
        if (limitMinutes <= 0) {
          timeLabel = 'Unlimited';
        } else if (Number.isFinite(state.autoDailyRemainingSeconds)) {
          const remainingSeconds = Math.max(0, Math.floor(state.autoDailyRemainingSeconds));
          const hours = Math.floor(remainingSeconds / 3600);
          const minutes = Math.floor((remainingSeconds % 3600) / 60);
          timeLabel = `${hours}h ${String(minutes).padStart(2, '0')}m`;
        }
        let deathsLabel = '';
        if (maxDeaths > 0) {
          const remainingDeaths = Math.max(0, maxDeaths - Number(state.autoDeathCount || 0));
          deathsLabel = ` â˜ :${remainingDeaths}`;
        }
        autoTooltipEl.textContent = `${timeLabel}${deathsLabel}`;
      } else {
        autoTooltipEl.textContent = '--:--';
      }
    }
  }

  function startAutoMode() {
    if (!state.autoAvailable) {
      showNotification('Auto-combat is locked. You need the correct account upgrade to use this.');
      return;
    }
    if (!isCombatTabActive()) {
      showNotification('Auto-combat only runs on the Combat tab.');
      return;
    }
    if (state.autoMode) {
      return;
    }
    if (state.inCombat) {
      if (isAutoBlockedTargetId(state.currentMonsterId)) {
        showNotification(autoBlockedTargetMessage(state.currentMonsterId));
        return;
      }
    } else if (!hasValidAutoTargetSelection()) {
      showNotification('Select a monster first.');
      return;
    }
    state.autoMode = true;
    state.autoStartedAt = Date.now();
    state.autoKillCount = 0;
    state.autoDeathCount = 0;
    window.AutoCombat = window.AutoCombat || {};
    window.AutoCombat.isRunning = true;
    updateAutoToggleLabel();
    logAutoCombatEvent('start', '');
    maybeHandleAutoReady();
  }

  function stopAutoMode(showMessage, reason) {
    if (!state.autoMode) {
      return;
    }
    state.autoMode = false;
    state.autoStartedAt = 0;
    window.AutoCombat = window.AutoCombat || {};
    window.AutoCombat.isRunning = false;
    updateAutoToggleLabel();
    logAutoCombatEvent('stop', reason || '');
    if (showMessage && reason) {
      showNotification(reason);
    }
  }

  function autoElapsedMinutes() {
    if (!state.autoStartedAt) return 0;
    const now = Date.now();
    const elapsedMs = now - state.autoStartedAt;
    if (elapsedMs <= 0) return 0;
    return elapsedMs / 60000;
  }

  function checkAutoStopConditions() {
    if (!state.autoMode) return false;
    const maxMinutes = Number(state.autoMaxMinutes || 0);
    const maxDeaths = Number(state.autoMaxDeaths || 0);
    if (maxMinutes > 0) {
      const elapsedMinutes = autoElapsedMinutes();
      if (elapsedMinutes >= maxMinutes) {
        stopAutoMode(
          true,
          `Auto-combat stopped: session time limit reached (${maxMinutes} min/session).`,
        );
        return true;
      }
    }
    if (maxDeaths > 0) {
      const deaths = Number(state.autoDeathCount || 0);
      if (deaths >= maxDeaths) {
        stopAutoMode(true, `Auto-combat stopped: death limit reached (${maxDeaths} deaths).`);
        return true;
      }
    }
    return false;
  }

  function maybeHandleAutoReady() {
    if (!state.autoMode) return;
    if (!isCombatTabActive()) {
      stopAutoMode(true, 'Auto-combat stopped because you left the Combat tab.');
      return;
    }
    if (checkAutoStopConditions()) {
      return;
    }
    const isDead = (state.playerHp || 0) <= 0;
    if (isDead) {
      if (reviveButton && !reviveButton.disabled) {
        handleReviveClick();
      }
      return;
    }
    if (hasActiveCooldown() || state.delayActive || !state.canAttack) {
      return;
    }
    if (state.inCombat) {
      if (isAutoBlockedTargetId(state.currentMonsterId)) {
        stopAutoMode(true, autoBlockedTargetMessage(state.currentMonsterId));
        return;
      }
      attackOnly();
      return;
    }
    if (state.lastMonsterId) {
      const lastId = String(state.lastMonsterId);
      const blocked = isAutoBlockedTargetId(lastId);
      const selectable = isSelectableTargetId(lastId);
      if (blocked && selectable) {
        stopAutoMode(true, autoBlockedTargetMessage(lastId));
        return;
      }
      if (!selectable) {
        const selectedId = getSelectedMonsterId();
        if (
          selectedId &&
          !isAutoBlockedTargetId(selectedId) &&
          isSelectableTargetId(selectedId)
        ) {
          state.lastMonsterId = selectedId;
          domLastSelectedId = selectedId;
          persistLastMonsterId(selectedId);
          if (selectEl) {
            selectEl.setAttribute('data-last-selected', selectedId);
          }
          refightLast();
          return;
        }
        state.lastMonsterId = null;
        persistLastMonsterId(null);
        return;
      }
      refightLast();
      return;
    }
    const selectedId = getSelectedMonsterId();
    if (selectedId) {
      if (isAutoBlockedTargetId(selectedId)) {
        stopAutoMode(true, autoBlockedTargetMessage(selectedId));
        return;
      }
      if (isSelectableTargetId(selectedId)) {
        state.lastMonsterId = selectedId;
        domLastSelectedId = selectedId;
        persistLastMonsterId(selectedId);
        if (selectEl) {
          selectEl.setAttribute('data-last-selected', selectedId);
        }
        refightLast();
      }
      return;
    }
    stopAutoMode(true, 'Auto-combat stopped: Select a monster first.');
  }

  function handleVisibilityChange() {
    if (!state.autoMode) return;
    if (document.visibilityState !== 'visible') {
      stopAutoMode(true, 'Auto-combat stopped because the browser tab is inactive.');
    }
  }

  document.addEventListener('visibilitychange', handleVisibilityChange);

  function handleTestingPhase1(data) {
    if (!data || !data.force_testing_phase1) return false;
    window.location.href = 'game.php?tab=combat';
    return true;
  }

  function applyResponse(data, sourceAction) {
    if (!data) return;
    if (handleTestingPhase1(data)) {
      return;
    }
    const actionContext = sourceAction || 'unknown';

    if (data.error === 'combat_tab_required') {
      stopAutoMode(true, data.notice || 'Combat is only allowed from the Combat tab.');
      return;
    }
    if (data.error === 'botcheck_required') {
      const token =
        data.botcheck && data.botcheck.token ? data.botcheck.token : '';
      const expiresIn = data.botcheck && typeof data.botcheck.expires_in === 'number'
        ? data.botcheck.expires_in
        : 10;
      const prompt = data.botcheck && data.botcheck.prompt ? data.botcheck.prompt : null;
      setBotcheckPrompt(prompt);
      showBotcheck(token, data.notice || '', expiresIn);
      return;
    }
    if (data.error === 'botcheck_logout') {
      hideBotcheck();
      handleCombatLogout(data.notice || 'You have been logged out.');
      return;
    }
    if (data.error === 'botcheck_failed') {
      hideBotcheck();
      if (data.notice) {
        showNotification(data.notice);
      }
      return;
    }
    if (data.botcheck_passed) {
      hideBotcheck();
      if (data.notice) {
        showNotification(data.notice);
      }
      return;
    }

    if (data.tournament_result === 'lost') {
      showNotification('You have been eliminated from the tournament.');
      try {
        const activeTabEl = document.querySelector(
          'a[data-active-tab="1"][data-tab-id]',
        );
        const activeTabId = activeTabEl
          ? activeTabEl.getAttribute('data-tab-id')
          : null;
        if (activeTabId === 'tournament') {
          window.location.href = 'game.php?tab=combat';
          return;
        }
      } catch (e) {
        window.location.href = 'game.php?tab=combat';
        return;
      }
    }

    const character = data.char || {};
    if (typeof character.hp === 'number') {
      state.playerHp = character.hp;
    }
    if (typeof character.max_hp === 'number') {
      state.playerMaxHp = character.max_hp;
    }
    if (typeof character.exp === 'number') {
      state.playerExp = character.exp;
    }
    if (typeof character.exp_to_next === 'number') {
      state.playerExpToNext = character.exp_to_next;
    }
    if (character.gold !== undefined && character.gold !== null) {
      const g = Number(character.gold);
      if (!Number.isNaN(g)) {
        state.playerGold = g;
      }
    }
    if (character.silver !== undefined && character.silver !== null) {
      const s = Number(character.silver);
      if (!Number.isNaN(s)) {
        state.playerSilver = s;
      }
    }
    if (typeof character.level === 'number') {
      state.playerLevel = character.level;
    }
    if (typeof character.stat_points === 'number') {
      state.statPoints = character.stat_points;
    }
    const serverLastMonsterId = normalizeMonsterId(character.last_monster_id);
    const currentLastMonsterId = normalizeMonsterId(state.lastMonsterId);
    const keepBeastTarget =
      currentLastMonsterId && String(currentLastMonsterId).startsWith('beast:');
    if (serverLastMonsterId && !keepBeastTarget) {
      state.lastMonsterId = serverLastMonsterId;
      persistLastMonsterId(serverLastMonsterId);
    } else if (!state.lastMonsterId && cachedLastMonsterId) {
      state.lastMonsterId = cachedLastMonsterId;
    }
    state.inCombat = !!data.combat;
    if (data.auto_usage && typeof data.auto_usage === 'object') {
      const limitMinutes = Number(data.auto_usage.daily_limit_minutes);
      state.autoDailyLimitMinutes = Number.isFinite(limitMinutes) && limitMinutes > 0
        ? limitMinutes
        : 0;
      const remainingSeconds = Number(data.auto_usage.daily_remaining_seconds);
      state.autoDailyRemainingSeconds = Number.isFinite(remainingSeconds)
        ? remainingSeconds
        : null;
      updateAutoToggleLabel();
    }
    syncDelayFromPayload(data.cooldown || character, actionContext);
    if (data.combat) {
      state.abilityName = data.combat.ability_name || '';
      state.abilityDesc = data.combat.ability_desc || '';
      state.currentMonsterId =
        data.combat.monster_id !== undefined && data.combat.monster_id !== null
          ? String(data.combat.monster_id)
          : null;
    } else {
      state.abilityName = '';
      state.abilityDesc = '';
      state.currentMonsterId = null;
    }

    updateHeaderHud();
    updateMainButtonLabel();

    if (data.combat) {
      // New combat or updated combat state: allow PvP events again.
      pvpSuppressed = false;

      if (nameEl) {
        nameEl.textContent =
          data.combat.monster_name + ' (Lvl ' + data.combat.monster_level + ')';
      }
      if (hpTextEl) {
        hpTextEl.textContent =
          formatInt(data.combat.current_hp) +
          ' / ' +
          formatInt(data.combat.max_hp);
      }
      if (hpBarEl) {
        const pct =
          data.combat.max_hp > 0
            ? (data.combat.current_hp / data.combat.max_hp) * 100
            : 0;
        hpBarEl.style.width = pct + '%';
      }
      setAbilityText(
        data.combat.ability_name || '',
        data.combat.ability_desc || '',
      );
      ensureCurrentMonsterVisible(data.combat);
    } else {
      if (nameEl) nameEl.textContent = '';
      if (hpTextEl) hpTextEl.textContent = '';
      if (hpBarEl) hpBarEl.style.width = '0%';

      // When the player is dead, do not show any monster ability
      // preview (this avoids confusing "Gelatinous Recovery" style text
      // appearing after a PvP death). Just reset the ability area.
      if ((state.playerHp || 0) <= 0) {
        setAbilityText('', '');
        clearTemporaryMonsterOption();
      } else {
        setMonsterSelectValue(state.lastMonsterId);
        setTimeout(() => {
          setMonsterSelectValue(state.lastMonsterId);
        }, 75);
        updateAbilityFromSelect();
        clearTemporaryMonsterOption();
      }
    }

    if (data.avatars) {
      updateAvatarDisplay(data.avatars, data.combat || null);
    }

    if (data.auto_disabled || (state.autoMode && (data.error === 'auto_limit_reached' || data.error === 'auto_disabled'))) {
      const message =
        data.notice ||
        (data.error === 'auto_limit_reached'
          ? 'Auto-combat stopped: usage limit reached.'
          : 'Auto-combat has been disabled by an administrator.');
      stopAutoMode(true, message);
      // Clear local cooldown UI so the player does not see the auto loop continuing.
      state.nextActionReadyAt = 0;
      state.delayActive = false;
      state.canAttack = true;
      if (cooldownTimer) {
        clearTimeout(cooldownTimer);
        cooldownTimer = null;
      }
      stopDelayTicker();
      renderDelayIndicator(true);
      toggleCombatDisplay(state.inCombat || state.delayActive);
    }

    if (logEl) {
      const logs = data.log || [];
      renderLogEntries(logs);
      if (state.autoMode && Array.isArray(logs) && logs.length > 0) {
        let sawKill = false;
        let sawDeath = false;
        logs.forEach((entry) => {
          const type = getLogEntryType(entry);
          const lower = getLogEntryText(entry).toLowerCase();
          if (type === 'monster-defeated' || lower.includes('defeated') || lower.includes('slain')) {
            sawKill = true;
          }
          if (type === 'player-defeat' || lower.includes('you have been defeated') || lower.includes('you were defeated')) {
            sawDeath = true;
          }
        });
        if (sawKill) {
          state.autoKillCount += 1;
        }
        if (sawDeath) {
          state.autoDeathCount += 1;
        }
        checkAutoStopConditions();
      }
    }
    const isAutoNoActiveCombatNotice =
      state.autoMode &&
      actionContext === 'fight' &&
      data.success === false &&
      !data.error &&
      typeof data.notice === 'string' &&
      data.notice.trim().toLowerCase() === 'no active combat.';
    const shouldToastNotice =
      data.notice &&
      !isAutoNoActiveCombatNotice &&
      (actionContext !== 'fight' || data.success === false || data.error);
    if (shouldToastNotice) {
      showNotification(data.notice);
    }
    toggleRevivePanel((state.playerHp || 0) <= 0);
    toggleCombatDisplay(state.inCombat || state.delayActive);
    updateMainButtonDisabled();
    updateAutoToggleLabel();
  }

  function showNotification(message) {
    if (
      window.gameNotifications &&
      typeof window.gameNotifications.show === 'function'
    ) {
      window.gameNotifications.show(message);
    }
  }

  function hideNotification() {
    if (
      window.gameNotifications &&
      typeof window.gameNotifications.hide === 'function'
    ) {
      window.gameNotifications.hide();
    }
  }

  function toggleRevivePanel(show) {
    if (!revivePanel) return;
    revivePanel.classList.toggle('hidden', !show);
    updateReviveButtonDisabled();
  }

  function toggleCombatDisplay(active) {
    // When the player is dead, always show the placeholder state and
    // hide the active combat block, regardless of cooldown or other
    // flags. This prevents the UI from flickering between "No enemy
    // selected" and a stale combat panel while waiting to revive.
    const isDead = (state.playerHp || 0) <= 0;
    const showActivePanel = !isDead && !!state.inCombat;
    const showPlaceholder = !showActivePanel;
    if (placeholderEl) {
      placeholderEl.classList.toggle('hidden', !showPlaceholder);
    }
    if (activeEl) {
      activeEl.classList.toggle('hidden', showPlaceholder);
    }
  }

  function hasActiveCooldown() {
    const readyAt = Number(state.nextActionReadyAt || 0);
    return readyAt > Date.now();
  }

  function updateMainButtonDisabled() {
    if (!buttonEl) return;
    const disable =
      hasActiveCooldown() || state.delayActive || !state.canAttack || actionInFlight;
    buttonEl.disabled = disable;
    buttonEl.classList.toggle('opacity-50', disable);
    buttonEl.classList.toggle('pointer-events-none', disable);
  }

  function updateReviveButtonDisabled() {
    if (!revivePanel || !reviveButton) return;
    const isDead = (state.playerHp || 0) <= 0;
    const hasCooldown =
      hasActiveCooldown() || state.delayActive || !state.canAttack || actionInFlight;
    const disable = isDead && hasCooldown;
    reviveButton.disabled = disable;
    revivePanel.classList.toggle('opacity-50', disable);
    revivePanel.classList.toggle('pointer-events-none', disable);
  }

  function getCurrentLogEntries() {
    if (!logEl) return [];
    const nodes = Array.from(logEl.querySelectorAll('.log-line'));
    return nodes.map((el) => {
      const targetSpan = el.querySelector('.pvp-target-link[data-target-player]');
      const target =
        targetSpan && targetSpan.getAttribute('data-target-player')
          ? targetSpan.getAttribute('data-target-player')
          : '';
      return {
        text: el.textContent || '',
        type: el.getAttribute('data-log-type') || 'neutral',
        target: target || '',
      };
    });
  }

  const pvpPlayerNames = {};

  function renderLogEntries(entries) {
    if (!logEl) return;
    if (!entries || entries.length === 0) {
      logEl.innerHTML = '';
      return;
    }
    const list = Array.isArray(entries) ? entries.slice() : [];
    const visible = list.slice(-VISIBLE_LOG_LINES);
    logEl.innerHTML = visible
      .map((entry) => {
        const text = getLogEntryText(entry);
        const typeAttr = getLogEntryType(entry);
        const targetValue =
          entry &&
          typeof entry === 'object' &&
          entry.target !== undefined &&
          entry.target !== null
            ? String(entry.target)
            : '';
        let innerHtml = escapeHtml(text);
        if (targetValue && pvpPlayerNames[targetValue]) {
          const name = String(pvpPlayerNames[targetValue]);
          const idx = text.indexOf(name);
          if (idx !== -1) {
            const before = text.slice(0, idx);
            const after = text.slice(idx + name.length);
            innerHtml =
              escapeHtml(before) +
              '<span class="pvp-target-link" data-target-player="' +
              escapeHtml(targetValue) +
              '">' +
              escapeHtml(name) +
              '</span>' +
              escapeHtml(after);
          }
        }
        return (
          '<div class="log-line ' +
          getLogLineClass(entry) +
          '" data-log-type="' +
          escapeHtml(typeAttr) +
          '">' +
          innerHtml +
          '</div>'
        );
      })
      .join('');
  }

  function appendPvpLogEvents(events) {
    if (!logEl || !Array.isArray(events) || events.length === 0) {
      return;
    }
    const current = getCurrentLogEntries();
    const mapped = events.map((ev) => ({
      text:
        ev && ev.text !== undefined && ev.text !== null
          ? String(ev.text)
          : '',
      type:
        ev && ev.type !== undefined && ev.type !== null
          ? String(ev.type)
          : 'neutral',
      target:
        ev && ev.target !== undefined && ev.target !== null
          ? String(ev.target)
          : '',
    }));
    const combined = current.concat(mapped);
    renderLogEntries(combined);

    const hasDefeat = mapped.some((ev) => {
      const type = String(ev.type || '').toLowerCase();
      const text = String(ev.text || '').toLowerCase();
      if (type === 'player-defeat') return true;
      if (text.includes('you have been defeated')) return true;
      return false;
    });
    if (hasDefeat) {
      state.playerHp = 0;
      // Update header HUD to reflect 0 HP immediately.
      updateHeaderHud();
      // Ensure revive panel is visible and enabled, and combat UI is reset.
      toggleRevivePanel(true);
      toggleCombatDisplay(false);

      // Extra safety: directly update HP UI elements in case the shared HUD
      // helper is not available or has not been initialized yet.
      try {
        const hpBar = document.getElementById('player-hp-bar');
        const hpText = document.getElementById('player-hp-text');
        if (hpBar) {
          hpBar.style.width = '0%';
        }
        if (hpText) {
          const maxHp = state.playerMaxHp || 0;
          hpText.textContent = '0 / ' + maxHp;
        }
      } catch (e) {
        // ignore HUD fallback failures
      }
    }
  }

  let lastPvpEventId = 0;
  let pvpSuppressed = false;
  let lastNearbyPlayersSignature = null;

  function clearCombatLog() {
    renderLogEntries([]);
    lastPvpEventId = 0;
    // Temporarily suppress PvP events so old duel messages do not re-appear
    // after a movement or other non-combat action.
    pvpSuppressed = true;
  }

  function updateNearbyPlayersOptions(players) {
    if (!selectEl) return;
    const list = Array.isArray(players) ? players : [];
    const signature = list
      .map((p) => {
        if (!p) return '';
        const id = typeof p.id === 'number' ? p.id : Number(p.id || 0);
        if (!id) return '';
        const name = (p.name || '').toString();
        const level =
          typeof p.level === 'number' && Number.isFinite(p.level)
            ? p.level
            : Number(p.level || 0);
        return id + '|' + level + '|' + name;
      })
      .filter((entry) => entry !== '')
      .join(',');
    const prevValue = selectEl.value || '';
    let optgroup = selectEl.querySelector('#player-options-group');
    if (signature === lastNearbyPlayersSignature && optgroup) {
      return;
    }
    lastNearbyPlayersSignature = signature;
    if (!optgroup && list.length === 0) {
      return;
    }
    if (!optgroup) {
      optgroup = document.createElement('optgroup');
      optgroup.id = 'player-options-group';
      optgroup.label = 'Players Here';
      const beastGroup = selectEl.querySelector('#beast-options-group');
      if (beastGroup && beastGroup.parentNode === selectEl) {
        // Keep players above beasts if both groups exist.
        selectEl.insertBefore(optgroup, beastGroup);
      } else {
        // Otherwise insert right after the placeholder option if present.
        const firstOption = selectEl.querySelector('option');
        if (firstOption && firstOption.parentNode === selectEl) {
          selectEl.insertBefore(optgroup, firstOption.nextSibling);
        } else {
          selectEl.appendChild(optgroup);
        }
      }
    }
    optgroup.innerHTML = '';
    list.forEach((p) => {
      if (!p) return;
      const id = typeof p.id === 'number' ? p.id : Number(p.id || 0);
      if (!id) return;
      const name = p.name || 'Player';
      pvpPlayerNames['player:' + String(id)] = name;
      const level =
        typeof p.level === 'number' && Number.isFinite(p.level)
          ? p.level
          : 1;
      const option = document.createElement('option');
      option.value = 'player:' + String(id);
      option.textContent = name + ' (Lvl ' + level + ')';
      option.setAttribute('data-ability-name', name);
      option.setAttribute(
        'data-ability-desc',
        'Challenge ' + name + ' to a duel.',
      );
      optgroup.appendChild(option);
    });
    // Try to keep the previously selected value if it still exists.
    if (prevValue) {
      const options = Array.from(selectEl.options || []);
      if (options.some((opt) => opt.value === prevValue)) {
        selectEl.value = prevValue;
      } else if (state.inCombat && state.currentMonsterId) {
        selectEl.value = String(state.currentMonsterId);
      }
    }
  }

  async function pollPvpLog() {
    if (!logEl) return;
    const fd = new FormData();
    fd.append('action', 'pvp_sync');
    fd.append('csrf_token', window.csrfToken || '');
    fd.append('since_id', String(lastPvpEventId || 0));
    try {
      const res = await fetch('api/combat_api.php', {
        method: 'POST',
        body: fd,
        credentials: 'same-origin',
      });
      const text = await res.text();
      let data = null;
      try {
        data = JSON.parse(text);
      } catch (e) {
        return;
      }
      if (handleTestingPhase1(data)) {
        return;
      }
      if (!data || !data.success) return;
      const events = Array.isArray(data.events) ? data.events : [];
      if (Array.isArray(data.nearby_players)) {
        updateNearbyPlayersOptions(data.nearby_players);
      }
      if (!pvpSuppressed && events.length > 0) {
        appendPvpLogEvents(events);
      }
      if (data.char && typeof data.char === 'object') {
        const ch = data.char;
        if (typeof ch.hp === 'number') {
          state.playerHp = ch.hp;
        }
        if (typeof ch.max_hp === 'number') {
          state.playerMaxHp = ch.max_hp;
        }
        updateHeaderHud();
        const isDead = (state.playerHp || 0) <= 0;
        toggleRevivePanel(isDead);
        if (isDead) {
          toggleCombatDisplay(false);
        }
      }
      if (typeof data.last_id === 'number') {
        lastPvpEventId = data.last_id;
      }
    } catch (e) {
      // swallow sync errors
    }
  }

  function schedulePvpPolling(intervalMs) {
    if (!logEl || intervalMs <= 0) return;
    if (pvpPollTimer && pvpPollInterval === intervalMs) return;
    if (pvpPollTimer) {
      clearInterval(pvpPollTimer);
      pvpPollTimer = null;
    }
    pvpPollInterval = intervalMs;
    pollPvpLog();
    // Poll PvP events more frequently than chat so duel logs feel snappy.
    pvpPollTimer = setInterval(pollPvpLog, intervalMs);
  }

  if (logEl) {
    logEl.addEventListener('click', (ev) => {
      const targetEl = ev.target.closest('.pvp-target-link[data-target-player]');
      if (!targetEl) return;
      if (state.isTournamentPlane) return;
      const targetValue = targetEl.getAttribute('data-target-player');
      if (!targetValue) return;
      const changed = setMonsterSelectValue(targetValue);
      if (changed && buttonEl) {
        buttonEl.focus();
      }
    });
  }

  function isProbablyLoginPage(html) {
    if (!html) return false;
    const text = String(html);
    const lower = text.toLowerCase();
    // Heuristic: only treat as a login page if we see a typical login form
    // with both email + password fields. This avoids mislabeling generic
    // error pages or other HTML as a forced logout.
    const hasEmailField =
      lower.indexOf('name=\"email\"') !== -1 ||
      lower.indexOf('name=\\\"email\\\"') !== -1;
    const hasPasswordField =
      lower.indexOf('type=\"password\"') !== -1 ||
      lower.indexOf('type=\\\"password\\\"') !== -1;
    return hasEmailField && hasPasswordField;
  }

  function handleCombatLogout(message) {
    console.warn('Combat session appears to be logged out.');
    // Stop auto-combat if it is running so the UI does not
    // misleadingly show "Auto: On" when actions can no longer
    // reach the server.
    stopAutoMode(false);
    // Clear any local cooldown so the delay bar is not stuck.
    state.nextActionReadyAt = 0;
    state.delayActive = false;
    state.canAttack = true;
    if (cooldownTimer) {
      clearTimeout(cooldownTimer);
      cooldownTimer = null;
    }
    stopDelayTicker();
    renderDelayIndicator(true);
    toggleCombatDisplay(state.inCombat || state.delayActive);

    if (window.handlePossibleLogoutSignal && typeof window.handlePossibleLogoutSignal === 'function') {
      window.handlePossibleLogoutSignal();
    } else if (window.gameNotifications && typeof window.gameNotifications.show === 'function') {
      window.gameNotifications.show(message || 'You have been logged out. Please refresh and log in again.');
    }
  }

  async function sendAction(action, extra) {
    if (botcheckActive && action !== 'botcheck') {
      showBotcheck(botcheckToken);
      return;
    }
    if (actionInFlight) {
      return;
    }
    actionInFlight = true;
    updateMainButtonDisabled();
    updateReviveButtonDisabled();
    const fd = new FormData();
    fd.append('action', action);
    fd.append('csrf_token', window.csrfToken || '');
    const activeTabId = getActiveTabId();
    if (activeTabId) {
      fd.append('tab', activeTabId);
    }
    if (extra) {
      Object.keys(extra).forEach((k) => fd.append(k, extra[k]));
    }


    try {
      const res = await fetch('api/combat_api.php', {
        method: 'POST',
        body: fd,
        credentials: 'same-origin',
      });
      if (res.status === 401) {
        console.warn('Combat API returned 401 (unauthenticated).');
        handleCombatLogout('You have been logged out. Please refresh and log in again.');
        return;
      }
      const contentType = res.headers.get('content-type') || '';
      const text = await res.text();
      if (
        contentType.indexOf('application/json') === -1 &&
        (text.indexOf('<title>Login</title>') !== -1 || isProbablyLoginPage(text))
      ) {
        console.warn('Combat API returned HTML that looks like the login page.');
        handleCombatLogout('You have been logged out. Please refresh and log in again.');
        return;
      }
      try {
        const data = JSON.parse(text);
        applyResponse(data, action);
      } catch (e) {
        console.error('Invalid JSON from combat_api.php:', text);
        // If parsing fails, allow the player to try again and reset local cooldown.
        state.canAttack = true;
        cooldownLocalOnly = false;
      }
    } catch (err) {
      console.error('Combat AJAX error:', err);
      // Network or fetch error: reâ€‘enable attacking and reset local cooldown so the UI isn't stuck.
      state.canAttack = true;
      cooldownLocalOnly = false;
    } finally {
      actionInFlight = false;
      updateMainButtonDisabled();
      updateReviveButtonDisabled();
      if (state.autoMode) {
        maybeHandleAutoReady();
      }
    }
  }

  function mainAction() {
    hideNotification();
    if (state.playerHp <= 0) {
      showNotification('You are dead. Revive before taking any actions.');
      toggleRevivePanel(true);
      return;
    }
    if (actionInFlight) {
      return;
    }
    let selectedId = getSelectedMonsterId();
    if (!selectedId && state.lastMonsterId) {
      if (setMonsterSelectValue(state.lastMonsterId)) {
        selectedId = state.lastMonsterId;
      } else {
        selectedId = state.lastMonsterId;
      }
    }
    const currentId =
      state.currentMonsterId !== null ? String(state.currentMonsterId) : '';
    const isSwitching =
      state.inCombat && selectedId && selectedId !== currentId;
    if (selectedId) {
      state.lastMonsterId = selectedId;
      domLastSelectedId = selectedId;
      persistLastMonsterId(selectedId);
      if (selectEl) {
        selectEl.setAttribute('data-last-selected', selectedId);
      }
    }

    if (isSwitching) {
      state.canAttack = false;
      sendAction('start_fight', { monster_id: selectedId });
      return;
    }

    if (state.inCombat) {
      attackOnly();
      return;
    }

    const hasCooldown =
      state.delayActive ||
      (state.nextActionReadyAt && state.nextActionReadyAt > Date.now()) ||
      !state.canAttack ||
      actionInFlight;
    if (hasCooldown) {
      return;
    }

    if (!selectedId) {
      return;
    }
    sendAction('start_fight', { monster_id: selectedId });
  }

  function attackOnly() {
    if (!state.inCombat) return;
    if (state.playerHp <= 0) {
      showNotification('You are dead. Revive before taking any actions.');
      toggleRevivePanel(true);
      return;
    }
    if (
      hasActiveCooldown() ||
      state.delayActive ||
      !state.canAttack ||
      actionInFlight
    ) {
      return;
    }
    hideNotification();
    // Begin local cooldown animation immediately; server response will sync timing.
    beginCooldown();
    const extra = {};
    if (state.autoMode) {
      extra.auto_combat = '1';
    }
    sendAction('fight', extra);
  }

  function refightLast() {
    hideNotification();
    if (state.inCombat) return;
    if (
      hasActiveCooldown() ||
      state.delayActive ||
      !state.canAttack ||
      actionInFlight
    ) {
      return;
    }
    if (state.playerHp <= 0) {
      showNotification('You are dead. Revive before taking any actions.');
      toggleRevivePanel(true);
      return;
    }
    if (!state.lastMonsterId) return;
    const extra = { monster_id: state.lastMonsterId };
    if (state.autoMode) {
      extra.auto_combat = '1';
    }
    // No cooldown gating for starting a new fight
    sendAction('start_fight', extra);
  }

  function selectTournamentOpponent() {
    if (!state.isTournamentPlane) return;
    if (!selectEl) return;
    const group = selectEl.querySelector('#player-options-group');
    if (!group) return;
    const option = group.querySelector('option');
    if (!option || !option.value) return;
    const value = String(option.value);
    selectEl.value = value;
    state.lastMonsterId = value;
    domLastSelectedId = value;
    persistLastMonsterId(value);
    if (selectEl) {
      selectEl.setAttribute('data-last-selected', value);
      selectEl.dispatchEvent(new Event('change', { bubbles: true }));
    }
    if (buttonEl) {
      buttonEl.focus();
    }
  }

  function handleSelectChange() {
    const selectedId = getSelectedMonsterId();
    if (selectedId) {
      if (
        state.isTournamentPlane &&
        typeof selectedId === 'string' &&
        selectedId.indexOf('player:') !== 0
      ) {
        // On the tournament plane, do not remember non-player targets.
        updateMainButtonLabel();
        return;
      }
      state.lastMonsterId = selectedId;
      domLastSelectedId = selectedId;
      persistLastMonsterId(selectedId);
      if (selectEl) {
        selectEl.setAttribute('data-last-selected', selectedId);
      }
    }
    // When the player is dead, do not auto-preview monster abilities;
    // the only relevant UI is the revive panel.
    if (!state.inCombat && (state.playerHp || 0) > 0) {
      updateAbilityFromSelect();
    }
    updateMainButtonLabel();
    if (state.autoMode && !state.inCombat) {
      if (!selectedId) {
        stopAutoMode(true, 'Auto-combat stopped: Select a monster first.');
        return;
      }
      if (isAutoBlockedTargetId(selectedId) || !isSelectableTargetId(selectedId)) {
        stopAutoMode(true, autoBlockedTargetMessage(selectedId));
        return;
      }
      maybeHandleAutoReady();
    }
  }

  function renderBeastOptions(beasts) {
    if (!beastGroupEl || !selectEl) return;
    const prevValue = selectEl.value;
    let html = '';
    (beasts || []).forEach((beast) => {
      const hpText = (beast.current_hp || 0) + '/' + (beast.max_hp || 0);
      html +=
        '<option value="' +
        escapeHtml(beast.id) +
        '" data-beast-option="1" ' +
        'data-ability-name="' +
        escapeHtml(beast.ability_name || '') +
        '" ' +
        'data-ability-desc="' +
        escapeHtml(beast.ability_desc || '') +
        '">' +
        escapeHtml(beast.name || 'Beast') +
        ' [' +
        hpText +
        '] (Lvl ' +
        (beast.level || 0) +
        ')</option>';
    });
    beastGroupEl.innerHTML = html;
    const hasPrev = Array.from(selectEl.options).some(
      (opt) => opt.value === prevValue,
    );
    if (hasPrev) {
      selectEl.value = prevValue;
    } else if (state.inCombat && state.currentMonsterId) {
      selectEl.value = state.currentMonsterId;
    } else {
      setMonsterSelectValue(domLastSelectedId || state.lastMonsterId);
    }
  }

  function replaceMonsterCatalog(monsters, tileRarity) {
    if (!selectEl) return;
    const list = Array.isArray(monsters) ? monsters : [];
    const prevValue = selectEl.value || '';
    const oldOptions = Array.from(
      selectEl.querySelectorAll('option[data-monster-option="1"]'),
    );
    oldOptions.forEach((opt) => opt.remove());

    const rarityPrefix =
      typeof tileRarity === 'string' && ['elite', 'rare'].includes(tileRarity)
        ? tileRarity.charAt(0).toUpperCase() + tileRarity.slice(1) + ' | '
        : '';

    const frag = document.createDocumentFragment();
    list.forEach((monster) => {
      const id = monster && monster.id !== undefined ? String(monster.id) : '';
      if (!id) return;
      const baseName =
        monster && monster.name !== undefined ? String(monster.name) : 'Monster';
      const levelRaw =
        monster && monster.level !== undefined ? Number(monster.level) : 0;
      const level = Number.isFinite(levelRaw) ? Math.max(0, Math.trunc(levelRaw)) : 0;
      const abilityName =
        monster &&
        monster.ability &&
        monster.ability.name !== undefined
          ? String(monster.ability.name)
          : '';
      const abilityDesc =
        monster &&
        monster.ability &&
        monster.ability.description !== undefined
          ? String(monster.ability.description)
          : '';

      const opt = document.createElement('option');
      opt.value = id;
      opt.setAttribute('data-monster-option', '1');
      opt.setAttribute('data-monster-name', baseName);
      opt.setAttribute('data-monster-level', String(level));
      opt.setAttribute('data-ability-name', abilityName);
      opt.setAttribute('data-ability-desc', abilityDesc);
      opt.textContent = rarityPrefix + baseName + ' (Lvl ' + level + ')';
      frag.appendChild(opt);
    });
    selectEl.appendChild(frag);

    const hasPrev = Array.from(selectEl.options || []).some(
      (opt) => opt.value === prevValue,
    );
    if (hasPrev) {
      selectEl.value = prevValue;
    } else if (state.inCombat && state.currentMonsterId) {
      selectEl.value = String(state.currentMonsterId);
    } else {
      setMonsterSelectValue(domLastSelectedId || state.lastMonsterId);
    }
    updateAbilityFromSelect();
    updateMainButtonLabel();
  }

  function fetchBeasts() {
    if (state.isTournamentPlane) {
      // Do not load beasts on the tournament plane.
      return;
    }
    fetch('api/beasts_api.php', { credentials: 'same-origin' })
      .then((res) => {
        if (!res.ok) throw new Error('beasts poll failed');
        return res.json();
      })
      .then((data) => {
        if (data && Array.isArray(data.beasts)) {
          state.beasts = data.beasts;
          if (isSelectBusy()) {
            deferBeastOptions(state.beasts);
            return;
          }
          renderBeastOptions(state.beasts);
          updateAbilityFromSelect();
        }
      })
      .catch(() => {
        /* swallow */
      });
  }

  function handleReviveClick() {
    if (!reviveButton) return;
    if ((state.playerHp || 0) > 0) {
      return;
    }
    if (
      hasActiveCooldown() ||
      state.delayActive ||
      !state.canAttack ||
      actionInFlight
    ) {
      return;
    }
    reviveButton.disabled = true;
    sendAction('revive');
  }

  if (reviveButton) {
    reviveButton.addEventListener('click', handleReviveClick);
  }

  if (buttonEl) {
    buttonEl.addEventListener('click', mainAction);
  }
  if (selectEl) {
    selectEl.addEventListener('change', handleSelectChange);
    selectEl.addEventListener('focus', () => {
      selectInteraction.isOpen = true;
    });
    selectEl.addEventListener('blur', () => {
      selectInteraction.isOpen = false;
      flushBeastOptions();
    });
    const markSelectBusy = () => {
      selectInteraction.suppressUntil = Date.now() + 1500;
    };
    selectEl.addEventListener('pointerdown', markSelectBusy);
    selectEl.addEventListener('touchstart', markSelectBusy);
    selectEl.addEventListener('mousedown', markSelectBusy);
  }
  if (autoToggleEl) {
    if (state.autoAvailable) {
      autoToggleEl.classList.remove('hidden');
    } else {
      autoToggleEl.classList.add('hidden');
    }
    autoToggleEl.addEventListener('click', () => {
      if (!state.autoAvailable) {
        showNotification('Auto-combat is locked. You need the correct account upgrade to use this.');
        return;
      }
      if (state.autoMode) {
        stopAutoMode(false);
      } else {
        startAutoMode();
      }
    });
  }

  if (!state.isTournamentPlane) {
    renderBeastOptions(state.beasts || []);
  }
  selectGuardTimer = setInterval(() => {
    if (isSelectBusy()) {
      return;
    }
    if (
      !selectEl ||
      state.inCombat ||
      (state.playerHp || 0) <= 0 ||
      !state.lastMonsterId ||
      getSelectedMonsterId() === String(state.lastMonsterId)
    ) {
      return;
    }
    setMonsterSelectValue(state.lastMonsterId);
  }, 200);
  if (
    !state.inCombat &&
    (state.lastMonsterId || domLastSelectedId) &&
    (state.playerHp || 0) > 0
  ) {
    setMonsterSelectValue(state.lastMonsterId || domLastSelectedId);
    setTimeout(() => {
      setMonsterSelectValue(state.lastMonsterId || domLastSelectedId);
    }, 75);
  }
  updateHeaderHud();
  toggleCombatDisplay(state.inCombat || state.delayActive);
  if (state.inCombat) {
    setAbilityText(state.abilityName || '', state.abilityDesc || '');
  } else {
    updateAbilityFromSelect();
  }
  updateMainButtonLabel();
  syncDelayFromPayload({
    action_delay_ms: state.actionDelayMs,
    next_action_ts: initialNextActionTs,
    next_action_ts_ms: initialNextActionTsMs,
  });
  updateAutoToggleLabel();

  function handleCombatHotkeys(e) {
    const key = (e.key || '').toLowerCase();
    const tag = (e.target && e.target.tagName ? e.target.tagName : '').toLowerCase();

    // If the user is typing in an input/textarea/select (e.g. chat box),
    // do not trigger any combat hotkeys, including revive.
    if (tag === 'input' || tag === 'textarea' || tag === 'select') {
      return;
    }

    if (key === 'a') {
      if (e.repeat) return;
      e.preventDefault();
      attackOnly();
    } else if (key === 'f') {
      e.preventDefault();
      if (state.isTournamentPlane) {
        selectTournamentOpponent();
      } else {
        refightLast();
      }
    } else if (key === 'r') {
      e.preventDefault();
      handleReviveClick();
    }
  }
  if (enableHotkeys) {
    document.addEventListener('keydown', handleCombatHotkeys);
  }

  function scheduleBeastPolling(intervalMs) {
    if (state.isTournamentPlane || intervalMs <= 0) {
      return;
    }
    if (beastPollTimer && beastPollInterval === intervalMs) {
      return;
    }
    if (beastPollTimer) {
      clearInterval(beastPollTimer);
      beastPollTimer = null;
    }
    beastPollInterval = intervalMs;
    fetchBeasts();
    beastPollTimer = setInterval(fetchBeasts, intervalMs);
  }

  function startCombatPolling() {
    if (!state.isTournamentPlane) {
      const beastInterval = isPageVisible()
        ? BEAST_POLL_INTERVAL
        : BEAST_POLL_HIDDEN_INTERVAL;
      scheduleBeastPolling(beastInterval);
    }
    const pvpInterval = isPageVisible()
      ? PVP_POLL_INTERVAL
      : PVP_POLL_HIDDEN_INTERVAL;
    schedulePvpPolling(pvpInterval);
  }

  function stopCombatPolling() {
    if (beastPollTimer) {
      clearInterval(beastPollTimer);
      beastPollTimer = null;
      beastPollInterval = 0;
    }
    if (pvpPollTimer) {
      clearInterval(pvpPollTimer);
      pvpPollTimer = null;
      pvpPollInterval = 0;
    }
  }

  function handleVisibilityChange() {
    startCombatPolling();
  }

  if (typeof document.visibilityState !== 'undefined') {
    document.addEventListener('visibilitychange', handleVisibilityChange);
  }
  handleVisibilityChange();

  // Expose shared helpers so other systems (e.g. map movement)
  // can clear the combat log when performing non-combat actions.
  window.CombatUI = window.CombatUI || {};
  window.CombatUI.clearLog = clearCombatLog;
  window.CombatUI.updateMonsterOptionsLabel = updateMonsterOptionLabels;
  window.CombatUI.replaceMonsterCatalog = replaceMonsterCatalog;
  window.CombatUI.refreshBeastsNow = fetchBeasts;
  window.CombatUI.endCombat = function endCombatFromMap() {
    state.inCombat = false;
    state.currentMonsterId = null;
    clearTemporaryMonsterOption();
    updateMainButtonLabel();
    toggleCombatDisplay(state.delayActive);
  };

  // Expose shared delay helpers so other game systems (e.g. map movement)
  // can respect and trigger the global action cooldown bar.
  window.CombatDelay = window.CombatDelay || {};
  window.CombatDelay.isOnCooldown = function isOnCooldown() {
    return hasActiveCooldown() || state.delayActive || !state.canAttack;
  };
  window.CombatDelay.getDelayDurationMs = function getDelayDurationMsPublic() {
    return getDelayDurationMs();
  };
  window.CombatDelay.beginExternalCooldown = function beginExternalCooldownPublic(
    durationMs,
  ) {
    beginExternalCooldown(durationMs);
  };
})();
