'use strict';

(function initHeaderPanel() {
    // Simple single-tab guard: only the most recently opened game.php tab
    // stays active. Older tabs will detect the change and redirect out.
    const SINGLE_TAB_STORAGE_KEY = 'rpg:active_game_tab';
    const myTabId = String(Date.now()) + ':' + String(Math.random());

    try {
        if (typeof window !== 'undefined' && window.localStorage) {
            window.localStorage.setItem(SINGLE_TAB_STORAGE_KEY, myTabId);
            window.addEventListener('storage', (event) => {
                if (!event || event.key !== SINGLE_TAB_STORAGE_KEY) return;
                const nextId = typeof event.newValue === 'string' ? event.newValue : '';
                if (!nextId || nextId === myTabId) {
                    return;
                }
                // Another tab has taken over: redirect this tab out of the game.
                try {
                    window.localStorage.removeItem(SINGLE_TAB_STORAGE_KEY);
                } catch (err) {
                    // ignore cleanup failures
                }
                window.location.href = 'login.php';
            });
            window.addEventListener('beforeunload', () => {
                try {
                    const current = window.localStorage.getItem(SINGLE_TAB_STORAGE_KEY);
                    if (current === myTabId) {
                        window.localStorage.removeItem(SINGLE_TAB_STORAGE_KEY);
                    }
                } catch (err) {
                    // ignore unload failures
                }
            });
        }
    } catch (err) {
        // Fail open if localStorage is unavailable.
    }

    const hpBarEl = document.getElementById('player-hp-bar');
    const hpTextEl = document.getElementById('player-hp-text');
    const expBarEl = document.getElementById('player-exp-bar');
    const expTextEl = document.getElementById('player-exp-text');
    const goldEl = document.getElementById('player-gold-value');
    const levelEl = document.getElementById('player-level-value');
    const silverEl = document.getElementById('player-silver-value');
    const drachmaEl = document.getElementById('player-drachma-value');
    const statButton = document.querySelector('[data-open-stat-modal]');
    const statPill = document.querySelector('[data-stat-points-pill]');
    const eventBadgeWrap = document.getElementById('hud-event-badges');
    const expEventBadge = document.getElementById('hud-exp-event-badge');
    const goldEventBadge = document.getElementById('hud-gold-event-badge');
    const locationCard = document.getElementById('hud-location-card');
    const planeNameEl = document.getElementById('hud-location-plane-name');
    const regionEl = document.getElementById('hud-location-region');
    const coordsEl = document.getElementById('hud-location-coords');
    const miniMapMarker = document.querySelector('[data-mini-map-marker]');
    const miniMapImage = document.querySelector('[data-mini-map-image]');
    const miniMapViewport = miniMapImage ? miniMapImage.parentElement : null;
    const MINI_MAP_ZOOM = 2.3;
    const MINI_MAP_SOFT_FOLLOW_THRESHOLD = 0;
    let miniMapPanX = 0;
    let miniMapPanY = 0;
    let miniMapPanInitialized = false;

    // Only add entries here when the HUD mini-map needs custom math.
    const markerConfigs = {
        gaia: {
            offsetLeft: 0,
            offsetTop: 0,
            width: 100,
            height: 100,
            useTileCenter: true
        },
        aerion: {
            offsetLeft: 9,
            offsetTop: 9,
            width: 82,
            height: 82,
            useTileCenter: true
        },
    };
    const defaultMarkerConfig = {
        offsetLeft: 0,
        offsetTop: 0,
        width: 100,
        height: 100,
        useTileCenter: true,
    };

    function getMarkerBounds(planeId) {
        return markerConfigs[planeId] || defaultMarkerConfig;
    }

    function getTileRatio(value, size, useTileCenter) {
        if (size <= 1) {
            return 0;
        }
        if (useTileCenter) {
            return (value + 0.5) / Math.max(1, size);
        }
        return value / Math.max(1, size - 1);
    }

    function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
    }

    function repositionMiniMapImage(leftPct, topPct) {
        if (!miniMapImage || !miniMapViewport) {
            return;
        }
        const rect = miniMapViewport.getBoundingClientRect();
        if (!rect.width || !rect.height) {
            return;
        }
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        const markerX = (leftPct / 100) * rect.width;
        const markerY = (topPct / 100) * rect.height;
        const deltaX = centerX - markerX;
        const deltaY = centerY - markerY;
        const maxPanX = ((MINI_MAP_ZOOM - 1) * rect.width) / 2;
        const maxPanY = ((MINI_MAP_ZOOM - 1) * rect.height) / 2;
        const thresholdX = rect.width * MINI_MAP_SOFT_FOLLOW_THRESHOLD;
        const thresholdY = rect.height * MINI_MAP_SOFT_FOLLOW_THRESHOLD;

        let targetPanX = miniMapPanX;
        let targetPanY = miniMapPanY;

        if (Math.abs(deltaX) > thresholdX) {
            targetPanX = clamp(deltaX, -maxPanX, maxPanX);
        }
        if (Math.abs(deltaY) > thresholdY) {
            targetPanY = clamp(deltaY, -maxPanY, maxPanY);
        }

        if (!miniMapPanInitialized) {
            miniMapPanInitialized = true;
        }
        miniMapPanX = targetPanX;
        miniMapPanY = targetPanY;

        miniMapImage.style.transformOrigin = 'center';
        miniMapImage.style.transform =
            `translate(${miniMapPanX}px, ${miniMapPanY}px) scale(${MINI_MAP_ZOOM})`;
    }

    function repositionMiniMapMarker() {
        if (!locationCard || !miniMapMarker) {
            return;
        }
        const planeId = locationCard.dataset.planeId || 'gaia';
        const planeWidth = Math.max(1, Number(locationCard.dataset.planeWidth) || 1);
        const planeHeight = Math.max(
            1,
            Number(locationCard.dataset.planeHeight) || 1,
        );
        const posX = Math.max(0, Number(locationCard.dataset.posX) || 0);
        const posY = Math.max(0, Number(locationCard.dataset.posY) || 0);
        const bounds = getMarkerBounds(planeId);
        const useTileCenter = bounds.useTileCenter !== false;
        const xRatio = getTileRatio(posX, planeWidth, useTileCenter);
        const yRatio = getTileRatio(posY, planeHeight, useTileCenter);
        const leftPct =
            bounds.offsetLeft + xRatio * bounds.width;
        const topPct =
            bounds.offsetTop + yRatio * bounds.height;
        miniMapMarker.style.left = `calc(${leftPct}% - 6px)`;
        miniMapMarker.style.top = `calc(${topPct}% - 6px)`;
        repositionMiniMapImage(leftPct, topPct);
    }

    function updateFullMapFromHud(payload) {
        if (
            window.MapControls &&
            typeof window.MapControls.updateFromHud === 'function'
        ) {
            try {
                window.MapControls.updateFromHud(payload);
            } catch (err) {
                // If the map controls script fails for some reason, we simply skip
                // mirroring into the full map rather than trying to reimplement its
                // positioning math here.
            }
        }
    }

    const formatInt =
        (window.App && typeof window.App.formatInt === 'function') ?
        window.App.formatInt :
        (value) => {
            const n = typeof value === 'number' && Number.isFinite(value) ?
                value :
                Number(value) || 0;
            return String(n);
        };

    window.updatePlayerHud = function updatePlayerHud(payload) {
        if (!payload || typeof payload !== 'object') return;

        if (
            hpBarEl &&
            hpTextEl &&
            typeof payload.hp === 'number' &&
            typeof payload.max_hp === 'number'
        ) {
            const maxHp = payload.max_hp > 0 ? payload.max_hp : 0;
            const hp = Math.max(0, Math.min(maxHp, payload.hp));
            const pct = maxHp > 0 ? (hp / maxHp) * 100 : 0;
            hpBarEl.style.width = Math.min(100, Math.max(0, pct)) + '%';
            hpTextEl.textContent = formatInt(hp) + ' / ' + formatInt(maxHp);
        }

        if (
            expBarEl &&
            expTextEl &&
            typeof payload.exp === 'number' &&
            typeof payload.exp_to_next === 'number'
        ) {
            const maxExp = payload.exp_to_next > 0 ? payload.exp_to_next : 0;
            const exp = Math.max(0, payload.exp);
            const pct = maxExp > 0 ? (exp / maxExp) * 100 : 0;
            expBarEl.style.width = Math.min(100, Math.max(0, pct)) + '%';
            expTextEl.textContent = formatInt(exp) + ' / ' + formatInt(maxExp);
        }

        if (goldEl && typeof payload.gold === 'number') {
            const gold = Math.max(0, payload.gold);
            goldEl.textContent = formatInt(gold) + ' G';
        }
        if (levelEl && typeof payload.level === 'number') {
            levelEl.textContent = payload.level;
        }
        if (silverEl && typeof payload.silver === 'number') {
            const silver = Math.max(0, payload.silver);
            silverEl.textContent = formatInt(silver) + ' S';
        }
        if (drachmaEl && typeof payload.drachma === 'number') {
            const drachma = Math.max(0, payload.drachma);
            drachmaEl.textContent = formatInt(drachma) + ' D';
        }
        if (coordsEl && typeof payload.pos_x === 'number' && typeof payload.pos_y === 'number') {
            const pad3 = (value) => {
                const n = Number.isFinite(value) ? Math.max(0, Math.trunc(value)) : 0;
                return String(n).padStart(3, '0');
            };
            let planeAbbrSource = '';
            if (typeof payload.plane_name === 'string' && payload.plane_name !== '') {
                planeAbbrSource = payload.plane_name;
            } else if (typeof payload.current_plane === 'string' && payload.current_plane !== '') {
                planeAbbrSource = payload.current_plane;
            }
            let planeAbbr = planeAbbrSource ? planeAbbrSource.slice(0, 3) : 'Pln';
            planeAbbr =
                planeAbbr.charAt(0).toUpperCase() + planeAbbr.slice(1).toLowerCase();
            coordsEl.textContent = `Loc: ${pad3(payload.pos_x)},${planeAbbr},${pad3(payload.pos_y)}`;
        }
        if (regionEl) {
            const town =
                typeof payload.town_name === 'string' ?
                payload.town_name.trim() :
                '';
            const zone =
                typeof payload.zone_name === 'string' ?
                payload.zone_name.trim() :
                '';
            if (town !== '') {
                regionEl.textContent = 'Town: ' + town;
            } else if (zone !== '') {
                regionEl.textContent = zone;
            }
        }
        if (planeNameEl && typeof payload.plane_name === 'string') {
            planeNameEl.textContent = payload.plane_name;
        }
        if (locationCard) {
            if (typeof payload.pos_x === 'number') {
                locationCard.dataset.posX = String(payload.pos_x);
            }
            if (typeof payload.pos_y === 'number') {
                locationCard.dataset.posY = String(payload.pos_y);
            }
            if (typeof payload.current_plane === 'string' && payload.current_plane !== '') {
                locationCard.dataset.planeId = payload.current_plane;
            }
            if (typeof payload.plane_width === 'number') {
                locationCard.dataset.planeWidth = String(payload.plane_width);
            }
            if (typeof payload.plane_height === 'number') {
                locationCard.dataset.planeHeight = String(payload.plane_height);
            }
            repositionMiniMapMarker();
        }
        if (
            miniMapImage &&
            typeof payload.map_image_url === 'string' &&
            payload.map_image_url !== ''
        ) {
            if (miniMapImage.getAttribute('src') !== payload.map_image_url) {
                miniMapImage.setAttribute('src', payload.map_image_url);
            }
        }

        if (
            typeof payload.pos_x === 'number' &&
            typeof payload.pos_y === 'number'
        ) {
            window.lastMapPayload = {
                coords: {
                    x: payload.pos_x,
                    y: payload.pos_y,
                },
                plane: {
                    id: payload.current_plane,
                    name: payload.plane_name,
                    width: payload.plane_width,
                    height: payload.plane_height,
                },
                zone_name: typeof payload.zone_name === 'string' ?
                    payload.zone_name :
                    '',
                town_name: typeof payload.town_name === 'string' ?
                    payload.town_name :
                    '',
                message: typeof payload.message === 'string' ?
                    payload.message :
                    '',
            };
            updateFullMapFromHud(window.lastMapPayload);
        }

        if (typeof payload.stat_points === 'number') {
            const statModal = document.getElementById('stat-allocation-modal');
            const modalOpen =
                statModal && !statModal.classList.contains('hidden');

            // When the stat allocation modal is open, let the modal's internal
            // state drive the visible stat point count to avoid flicker from
            // stale HUD payloads. Otherwise, update the header pill normally.
            if (!modalOpen) {
                if (statPill) {
                    statPill.textContent = Math.max(0, payload.stat_points);
                }
                if (statButton) {
                    statButton.classList.toggle(
                        'hidden',
                        payload.stat_points <= 0,
                    );
                }
            }

            if (
                window.statAllocation &&
                typeof window.statAllocation.updatePoints === 'function'
            ) {
                window.statAllocation.updatePoints(payload.stat_points);
            }
        }

        const hasExpFlag = Object.prototype.hasOwnProperty.call(payload, 'exp_event_active');
        const hasGoldFlag = Object.prototype.hasOwnProperty.call(payload, 'gold_event_active');
        if ((hasExpFlag || hasGoldFlag) && (expEventBadge || goldEventBadge || eventBadgeWrap)) {
            const expActive = hasExpFlag ?
                (typeof payload.exp_event_active === 'boolean' ?
                    payload.exp_event_active :
                    !!payload.exp_event_active) :
                expEventBadge && !expEventBadge.classList.contains('hidden');
            const goldActive = hasGoldFlag ?
                (typeof payload.gold_event_active === 'boolean' ?
                    payload.gold_event_active :
                    !!payload.gold_event_active) :
                goldEventBadge && !goldEventBadge.classList.contains('hidden');
            const stateKey = `${expActive ? '1' : '0'}:${goldActive ? '1' : '0'}`;
            const lastKey = eventBadgeWrap ? eventBadgeWrap.getAttribute('data-event-state') : null;
            if (eventBadgeWrap && lastKey === stateKey) {
                return;
            }
            if (eventBadgeWrap) {
                eventBadgeWrap.setAttribute('data-event-state', stateKey);
            }
            if (expEventBadge) {
                expEventBadge.classList.toggle('hidden', !expActive);
            }
            if (goldEventBadge) {
                goldEventBadge.classList.toggle('hidden', !goldActive);
            }
            if (eventBadgeWrap) {
                eventBadgeWrap.classList.toggle('hidden', !expActive && !goldActive);
            }
        }
    };

    function syncEventBadgesOnce() {
        fetch('api/hud_state.php', {
                credentials: 'same-origin'
            })
            .then((res) => {
                if (!res.ok) return null;
                return res.json();
            })
            .then((data) => {
                if (!data || !data.success) return;
                const events = data.events || {};
                window.updatePlayerHud({
                    exp_event_active: !!events.exp,
                    gold_event_active: !!events.gold,
                });
            })
            .catch(() => {
                // Swallow HUD refresh errors.
            });
    }

    syncEventBadgesOnce();

    const hasChatPanel = !!document.getElementById('chat-messages');
    if (!hasChatPanel) {
        const HUD_STATE_URL = 'api/hud_state.php';
        const HUD_POLL_INTERVAL_MS = 5000;
        let hudPollTimer = null;

        function pollHudState() {
            fetch(HUD_STATE_URL, {
                    credentials: 'same-origin'
                })
                .then((res) => {
                    if (!res.ok) return null;
                    return res.json();
                })
                .then((data) => {
                    if (!data || !data.success) return;
                    const events = data.events || {};
                    window.updatePlayerHud({
                        exp_event_active: !!events.exp,
                        gold_event_active: !!events.gold,
                    });
                })
                .catch(() => {
                    // Swallow HUD refresh errors.
                });
        }

        hudPollTimer = window.setInterval(pollHudState, HUD_POLL_INTERVAL_MS);
        pollHudState();

        if (typeof document.visibilityState !== 'undefined') {
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'hidden') {
                    if (hudPollTimer) {
                        clearInterval(hudPollTimer);
                        hudPollTimer = null;
                    }
                    return;
                }
                if (!hudPollTimer) {
                    hudPollTimer = window.setInterval(pollHudState, HUD_POLL_INTERVAL_MS);
                    pollHudState();
                }
            });
        }
    }

    repositionMiniMapMarker();

})();