'use strict';
(function initStatAllocationModal() {
    const modal = document.getElementById('stat-allocation-modal');
    if (!modal) return;
    let config = {};
    try {
        const raw = modal.getAttribute('data-stat-config') || '{}';
        config = raw ? JSON.parse(raw) : {}
    } catch (err) {
        console.error('Failed to parse stat allocation config', err);
        config = {}
    }
    const statPointsEl = modal.querySelector('[data-stat-points]');
    const statRows = modal.querySelectorAll('[data-stat-row]');
    const overlay = modal.querySelector('[data-stat-modal-overlay]');
    const closeButtons = modal.querySelectorAll('[data-stat-modal-close]');
    const snoozeKey = 'statModalSnooze:' + (config.user_id || '0');
    let state = {
        stat_points: Math.max(0, config.stat_points || 0),
        stats: config.stats || {},
        requesting: null,
    };

    function render() {
        if (statPointsEl) {
            statPointsEl.textContent = state.stat_points
        }
        statRows.forEach((row) => {
            const key = row.getAttribute('data-stat-row');
            const valueEl = row.querySelector('[data-stat-current]');
            const primaryButton = row.querySelector('[data-action="increment"][data-amount]', );
            const quickButtons = row.querySelectorAll('[data-action="increment"][data-amount][data-quick]', );
            if (valueEl && state.stats[key]) {
                valueEl.textContent = state.stats[key].value
            }
            const isRequesting = state.requesting === key;
            if (primaryButton) {
                const disabled = state.stat_points <= 0 || isRequesting;
                primaryButton.disabled = disabled;
                primaryButton.classList.toggle('opacity-50', disabled);
                primaryButton.classList.toggle('cursor-not-allowed', disabled)
            }
            quickButtons.forEach((btn) => {
                const amount = parseInt(btn.getAttribute('data-amount') || '0', 10);
                const canUse = Number.isFinite(amount) && amount > 0 && state.stat_points >= amount && !isRequesting;
                btn.disabled = !canUse;
                btn.classList.toggle('hidden', !canUse);
                btn.classList.toggle('opacity-50', !canUse);
                btn.classList.toggle('cursor-not-allowed', !canUse)
            })
        });
        const trigger = document.querySelector('[data-open-stat-modal]');
        const pill = document.querySelector('[data-stat-points-pill]');
        if (trigger) {
            if (state.stat_points > 0) {
                trigger.classList.remove('hidden')
            } else {
                trigger.classList.add('hidden')
            }
        }
        if (pill) {
            pill.textContent = state.stat_points
        }
    }

    function openModal() {
        modal.classList.remove('hidden');
        modal.setAttribute('aria-hidden', 'false')
    }

    function closeModal() {
        modal.classList.add('hidden');
        modal.setAttribute('aria-hidden', 'true')
    }

    function showError(message) {
        if (window.gameNotifications && typeof window.gameNotifications.show === 'function') {
            window.gameNotifications.show(message || 'Unable to allocate stat.')
        }
    }

    function updateTotals(totals) {
        if (!totals || typeof totals !== 'object') return;
        const formatInt = window.App && typeof window.App.formatInt === 'function' ? window.App.formatInt : (value) => {
            const n = typeof value === 'number' && Number.isFinite(value) ? value : Number(value) || 0;
            return String(n)
        };
        Object.keys(totals).forEach((key) => {
            const el = document.querySelector('[data-stat-value="' + key + '"]');
            if (el) {
                el.textContent = formatInt(totals[key])
            }
        })
    }

    function handleExternalUpdate(newPoints) {
        const previous = state.stat_points;
        const parsed = parseInt(newPoints, 10);
        const normalized = Number.isFinite(parsed) ? Math.max(0, parsed) : 0;
        if (!modal.classList.contains('hidden') && normalized > previous) {
            return
        }
        state.stat_points = normalized;
        render();
        if (state.stat_points > 0 && (!previous || previous <= 0) && sessionStorage.getItem(snoozeKey) !== '1') {
            const autoCombatRunning = window.AutoCombat && window.AutoCombat.isRunning === !0;
            if (autoCombatRunning) {
                sessionStorage.setItem(snoozeKey, '1')
            } else {
                openModal()
            }
        }
    }

    function sendAllocateRequest(stat, remaining) {
        if (!stat || remaining <= 0 || state.stat_points <= 0) {
            state.requesting = null;
            render();
            return
        }
        const requestedAmount = Math.min(remaining, state.stat_points);
        const beforePoints = state.stat_points;
        const fd = new FormData();
        fd.append('action', 'allocate');
        fd.append('stat', stat);
        fd.append('amount', String(requestedAmount));
        fd.append('csrf_token', window.csrfToken || '');
        fetch('api/stats_api.php', {
            method: 'POST',
            body: fd,
            credentials: 'same-origin',
        }).then((res) => res.json()).then((data) => {
            if (!data || !data.success) {
                showError((data && data.message) || 'Unable to allocate stat.', );
                state.requesting = null;
                render();
                return
            }
            const newPoints = typeof data.stat_points === 'number' && data.stat_points >= 0 ? data.stat_points : 0;
            const spent = Math.max(0, beforePoints - newPoints);
            state.stat_points = newPoints;
            if (window.CombatState && typeof newPoints === 'number') {
                window.CombatState.statPoints = newPoints
            }
            if (data.stats) {
                Object.keys(data.stats).forEach((key) => {
                    if (!state.stats[key]) {
                        state.stats[key] = {
                            value: data.stats[key]
                        }
                    } else {
                        state.stats[key].value = data.stats[key]
                    }
                })
            }
            if (typeof window.updatePlayerHud === 'function' && data.char) {
                window.updatePlayerHud(data.char)
            }
            updateTotals(data.stats || {});
            if (state.stat_points <= 0) {
                sessionStorage.removeItem(snoozeKey)
            }
            const remainingAfter = remaining - (spent || 1);
            if (remainingAfter > 0 && state.stat_points > 0) {
                sendAllocateRequest(stat, remainingAfter)
            } else {
                state.requesting = null;
                render()
            }
        }).catch(() => {
            showError('Unable to allocate stat.');
            state.requesting = null;
            render()
        })
    }

    function handleAllocate(stat, amount) {
        if (!stat || state.stat_points <= 0 || state.requesting) return;
        const parsedAmount = parseInt(amount, 10);
        let normalizedAmount = Number.isFinite(parsedAmount) ? parsedAmount : 1;
        if (normalizedAmount <= 0) {
            normalizedAmount = 1
        }
        normalizedAmount = Math.min(normalizedAmount, state.stat_points, 100);
        if (normalizedAmount <= 0) return;
        state.requesting = stat;
        render();
        sendAllocateRequest(stat, normalizedAmount)
    }
    modal.querySelectorAll('[data-action="increment"][data-amount]').forEach((btn) => {
        btn.addEventListener('click', () => handleAllocate(btn.getAttribute('data-stat'), btn.getAttribute('data-amount'), ), )
    });
    overlay ? .addEventListener('click', closeModal);
    closeButtons.forEach((btn) => btn.addEventListener('click', closeModal));
    const laterBtn = modal.querySelector('[data-stat-modal-later]');
    laterBtn ? .addEventListener('click', () => {
        sessionStorage.setItem(snoozeKey, '1');
        closeModal()
    });
    document.querySelectorAll('[data-open-stat-modal]').forEach((btn) => {
        btn.addEventListener('click', () => {
            sessionStorage.removeItem(snoozeKey);
            openModal()
        })
    });
    document.addEventListener('keydown', (evt) => {
        if (evt.key === 'Escape' && !modal.classList.contains('hidden')) {
            closeModal()
        }
    });
    const shouldAuto = Boolean((config.should_auto_open || config.stat_points > 0) && state.stat_points > 0 && sessionStorage.getItem(snoozeKey) !== '1', );
    if (shouldAuto) {
        setTimeout(openModal, 400)
    }
    render();
    window.statAllocation = window.statAllocation || {};
    window.statAllocation.updatePoints = handleExternalUpdate
})()